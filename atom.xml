<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MaxMak&#39;s House</title>
  <subtitle>iOS Developer|LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maxmak.tk/"/>
  <updated>2017-03-28T10:19:12.000Z</updated>
  <id>http://maxmak.tk/</id>
  
  <author>
    <name>Max Mak</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>所有权宣言 - Swift 官方文章 Ownership Manifesto 译文评注版</title>
    <link href="http://maxmak.tk/2017/02/27/2017-02-27-ownership/"/>
    <id>http://maxmak.tk/2017/02/27/2017-02-27-ownership/</id>
    <published>2017-02-26T22:40:00.000Z</published>
    <updated>2017-03-28T10:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 团队最近在邮件列表里向社区发了一封邮件，讲述了关于内存所有权方面的一些未来的改变方向。作为上层 API 的使用者来说，我们可能并不需要了解背后所有的事实，但是 Apple 的这封邮件中对 Swift 的值和对象的内存管理进行了很全面的表述，一步步说明了前因后果。如果你想深入学习和了解 Swift 的话，这篇文章是非常棒的参考资料。我尝试翻译了一下全文，并且加上了一些自己的注解。虽然这篇文章比较长，但是如果你想要进阶 Swift 的话，不妨花时间通读全文 (甚至通读全文若干遍)。</p>
<p>如果你没有时间通读全文，又想简单了解一下到底发生了什么的话，可以往下翻到最后，有一个我自己的简易的总结版本。</p>
<p>这篇文档本身是对今后 Swift 方向的一个提案，所以涉及的关键字和具体实现细节可能会有出入，不过这并不影响文章背后的思想。您可以在 Swift 的 repo 里找到<a href="https://github.com/apple/swift/blob/master/docs/OwnershipManifesto.md" target="_blank" rel="external">这篇文档的原文</a>。</p>
<p>这篇文章很长，读起来会比较花时间，不过因为内容还算循序渐进，只要静下心来就不会有太多困难。我在有些部分添加了个人的注解，会补充介绍一些背景知识和我自己的看法，你可以将它看成是我个人在读译本文时的笔记 (和吐槽)，它们将以 “译者注” 的方式在文中以引出出现。不过只是一家之言，仅供参考，还望斧正。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>将“所有权”作为一个重要特性添加到 Swift 中，会为程序员带来很多好处。这份文档同时扮演了所有权这一特性的“宣言”和“元提案”的角色。在本文中我们会陈述所有权相关工作的基本目的，并描述要达到这些目的所使用的一般方法。我们还会为一系列特定的变化和特性进行提案，每个提案都会在将来在更细的粒度上分别进行讨论。这篇文档想要做的是在全局上提供一个框架，以帮助理解每个变化所带来的贡献。</p>
<h3 id="问题现状"><a href="#问题现状" class="headerlink" title="问题现状"></a>问题现状</h3><p>在 Swift 中广泛使用的值类型写时复制 (copy-on-write) 特性取得了很大成功。不过，这个特性也还有一些不足：</p>
<blockquote>
<p>译者注：Swift 中的“写时复制”是指，值类型只在被改动前进行复制。传统意义上的值类型会在被传递或者被赋值给其他变量时就发生复制行为，但是这将会带来极大的，也是不必要的性能损耗。写时复制将在值被传递和赋值给变量时首先检查其引用计数，如果引用计数为 1 (唯一引用)，那么意味着并没有其他变量持有该值，对当前值的复制也就可以完全避免，以此在保持值类型不可变性的优良特性的同时，保证使用效率。Swift 中像是 <code>Array</code> 和 <code>Dictionary</code> 这样的类型都是值类型，但是底层实现确是引用类型，它们都利用了写时复制的技术来保证效率。</p>
</blockquote>
<ul>
<li><p>引用计数和引用唯一性的测试必然导致额外开销。</p>
</li>
<li><p>在大多数情况下引用计数可以决定性能特性，但是分析和预判写时复制的性能还是十分复杂。</p>
</li>
<li><p>在任何时候值都有可能被复制，这种复制会使值“逃逸”出原有作用范围，这会导致绝大部分底层缓冲区都会被申请在堆内存上。如果能在栈上申请内存的话，会比现在高效得多，但是这需要我们能够阻止，或者至少识别出那些将要逃逸的值。</p>
</li>
</ul>
<p>有些低层级的程序对于性能有着更严格的要求。通常它们并不要求绝对的高性能，但是却需要<strong>可以预测</strong>的性能特性。比如说，处理音频对于一个现在处理器来说并不是什么繁杂的工作，就算使用很高的采样率一般也能应付自如。但是只要有一点点预期外的停顿，就会立刻引起用户的注意。</p>
<blockquote>
<p>译者注：也就是说，相比于绝对的高性能，我们可能更希望有平稳的性能特性，来处理这些工作。避免代码性能上出现“尖刺”，让程序运行在可以预估的水平。这样一样，即使绝对性能不足，针对用户体验我们也可以很好的对策 (比如降低码率)，这可能比整体提升更重要，也更容易。</p>
</blockquote>
<p>另一个很常见的编程任务是优化现有代码，比如你在处理某项工作时遇到了性能上的瓶颈。通常我们会找到执行时间或者是内存使用上的“热点”，然后以某种方式修复它们。但是当这些热点是由于隐式的值复制导致的话，Swift 中现在几乎没有工具能对应这种情况。程序员可能会尝试退回到用非安全指针来处理，但是这种行为将让你丧失标准库中集合类型所带来的安全性和表达能力的优势。</p>
<blockquote>
<p>译者注：如果你觉得退回到非安全指针太过的话，也许退回到使用 <code>NSArray</code> 或者 <code>NSDictionary</code> 也会是一种选择。但是要注意数组或是字典中的类型最好也是 <code>NSObject</code> 子类，这样的回退才有意义。由于 Swift 中的类型和 Foundation 中的类型也存在一些隐式的桥接转换，这方面的性能开销往往被忽视。但是这样的妥协方式也并不理想，你同样失去了 Swift 的类型安全和泛型特性，同时可能你还需要大幅修改已有的模型类型，往往也得不偿失。</p>
</blockquote>
<p>我们认为，通过引入一些可选的特性，我们将能够纠正这些问题。我们将这一系列特性统合称为<strong>所有权</strong>。</p>
<h3 id="什么是所有权？"><a href="#什么是所有权？" class="headerlink" title="什么是所有权？"></a>什么是所有权？</h3><p><strong>所有权</strong>是指某段代码具有最终销毁一个值的责任。<strong>所有权系统</strong>则是管理和转移所有权的一整套规则及约定。</p>
<p>任何具有销毁概念的语言，也都有所有权的概念。在像是 C 和非 ARC 的 Objective-C 这样的语言中，所有权是由程序员自行进行管理的。在其他一些语言中，像是一部分 C++ 里，所有权由语言进行管理。即使在隐式内存管理的语言中，也存在有所有权概念的库，这是因为除了内存以外，还有其他的编程资源，而理解那些代码应该释放那些资源，是一件非常重要的事情。</p>
<blockquote>
<p>译者注：除了内存以外，其他的资源可能包括比如音频单元控制权、端口等等。这些资源也需要申请和释放，它们在这方面的运行逻辑和内存有相似之处。</p>
</blockquote>
<p>Swift 已经有一套所有权系统了，但是它往往“鲜为人知”：这套系统是语言的实现细节，程序员几乎没有办法对其施加影响。我们想要提案的内容可以总结为以下几点：</p>
<ul>
<li><p>我们应该向所有权系统中添加一条核心规则 - 独占性原则 (Law of Exclusivity)。这条原则应该阻止以互相冲突的方式同时访问某个变量 (比如，将一个变量以 <code>inout</code> 的方式传递给两个不同的函数)。这应该是一个必须的非可选改变，但是我们相信，这个改变对绝大多数的程序都不会产生不利影响。</p>
</li>
<li><p>我们应该添加一些特性，给程序员一定的手段来控制类型系统。首先，是允许被“共享”的值能传递下去。这将是一个可选的变更，它将由一系列的标注和语言特性组成，而程序员可以简单地选择不使用它。</p>
</li>
<li><p>我们应该添加一个特性，来让程序员表达唯一的所有权。换句话说，就是表达某个类型不能被隐式地复制。这将是一个可选的特性，能为那些想在这个层级进行控制的富有经验的程序员提供可行方式。我们不打算让普通的 Swift 程序也能够与这样的类型一同工作。</p>
</li>
</ul>
<p>以此三个改变作为支柱，我们将要把这门语言的所有权系统从实现细节提升到一个更加可见的层面。这三个改变虽然优先级稍有不同，但是它们确是不可分割的，我们稍后会详述原因。由于这邪恶原因，我们将三者进行捆绑内聚，并将它们统称作“所有权”特性。</p>
<h3 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h3><p>Swift 现在的所有权系统中的基本问题在于复制，有关所有权的这三个改变全都在尝试避免复制。</p>
<p>在程序里，一个值可能会被用在很多地方。我们的实现需要保证在这些被用到地方，值的复制是存在且可用的。只要这个值的类型是可以复制的，那么我们只要复制这个值就肯定可以满足使用的需求了。但是，对于绝大多数的使用场景来说，实际上它们自己并不需要对复制的值拥有所有权。确实存在需要这么做的情况：比如一个变量并不拥有它当前的值，它只能将值存储在别处，而存储的地方是被其他东西持有的。但是这种做法一般并没有什么实际用处。而像是从类的实例中读取一个值这样的简单操作，只要求实例本身可用，而不要求读取代码自身实际拥有那个值的所有权。有时候这种差别十分明显，但是有时候却又难以分辨。举例来说，编译器在一般情况下是无法知道某个函数将对它的参数做怎样的操作的。在是否传递值的所有权这件事上，编译器只能回退到默认规则。当默认规则不正确的时候，程序就会在运行时多出额外的复制操作。所以，我们能做的是在某些方面让程序能被写得更加明确，这能帮助编译器了解它们是否需要值的所有权。</p>
<p>我们想要支持不可复制的类型，而这个方法和我们的想法是吻合的。对于大多数资源的销毁，唯一性十分重要：内存只能被回收一次，文件只能被关闭一次，锁也只能被释放一次。很自然地，对于这类资源的引用的所有者，应该也是唯一的，它不应该能被复制。当然，我们可以人为地允许所有权被共享，譬如我们可以添加一个引用计数，只在计数变为 0 时销毁资源，但是这势必会对使用这些资源带来额外的开销。更糟的是，这种做法会引入并行 (concurrency) 和<a href="https://zh.wikipedia.org/wiki/可重入" target="_blank" rel="external">可重入</a> (re-entrancy) 的问题。如果所有权是唯一的，并且语言本身强制规定了对资源的某些操作只能发生在拥有这个资源的代码中的话，那么自然而然地，同一时间内就只能有一段代码执行这些操作。而一旦所有权可以被共享，这一特性就随之消失了。所以，在一门语言里添加对不可复制的类型的支持会十分有意思，因为它能让我们以优秀和高效的抽象表达形式来操作资源。不过，要支持这些类型的话，我们需要完整应对抽象的所有方面，比如正确地标注函数的参数，以指明其是否需要所有权转移。如果标注不正确的话，只是使用增加复制的方式，编译器也无法保证在幕后一切都正确运行。</p>
<blockquote>
<p>译者注：所有权唯一将会使资源管理的问题极为简化，但是事实上这样也会让程序变得无用。通过巧妙的语言设计 (或者说增加编译器开发者和语言开发者的压力)，可以在保持唯一性的同时与程序其他部分“共享”，不过这么做也会带来很多的复杂度。本文后面就将展示这些复杂度以及对应的方式。</p>
</blockquote>
<p>想要将这些问题里的任何一个解决好，我们都需要解决变量的非独占访问 (non-exclusive access) 的问题。Swift 现在是允许对一个同样的变量进行嵌套式访问的。比如说，你可以将同一个变量作为两个不同的 <code>inout</code> 参数进行传递，或者是在一个变量上调用某个方法，并且在这个方法所接受的回调参数中再去访问同一个变量。这类行为基本上是不被鼓励的，不过它们也没有被禁止。不仅如此，编译器和标准库在这种时候都必须“卑躬屈膝”，以保证如果发生问题的时候程序不要表现得过于离谱。举例来说，在发生原地的元素替换更改时，<code>Array</code> 必须要持有它自己的内存。若不这样做的话，试想要是在更改的时候我们以某种方式把原来的数组变量重新赋了值，那么这块内存就将被释放掉，而元素却还正在被更改。同样地，编译器一般也很难证明某个内存里的值在一个函数中不同的地方是否相同，因为它只能假设任何一个非透明的函数调用都有可能重写内存。这导致的结果是编译器只能像一个被迫害妄想症患者那样到处添加复制，保证冗余。更糟糕的是，非独占访问极大地限制了显式标注的实用性。比方说，一个 <code>shared</code> 参数只有在保证该参数在整个方法调用中都有效时，才有意义。但是，只有通过对一个变量的当前值进行复制并传递复制的值，才能可靠地保证该值可以在可重入的方式下进行更改。另外，非独占访问也让特定的重要的模式变得不可能实现，比如无法“盗取”当前值并创建新值，在执行的途中别的代码要是可以获取某个变量的话，是一件很糟糕的事情。要解决这个问题，唯一的方法是建立一个规则，来阻止多个上下文在同一时间访问同一变量。这就是我们的提案之一 - 独占性原则。</p>
<p>所有这三个目标都是紧密相连，并且互为加强的。独占性原则使得显式标注在默认情况下能确实优化代码，并且对不可复制的类型进行强制规范。显式标注在独占性原则的作用下，可以带来更多的优化机会，并让我们在函数中使用不可复制类型。不可复制类型能够验证即使对于可复制类型来说，标注也是最优选项，它们也为独占性原则能直接适用创造了更多的情境。</p>
<h3 id="成功的标准"><a href="#成功的标准" class="headerlink" title="成功的标准"></a>成功的标准</h3><p>如上所述，开发核心团队希望能将所有权作为可选的加强引入 Swift。程序员在很大程度上应该可以忽略所有权的问题，也不必为之操心。如果这一点被证明无法满足的话，我们会拒绝关于所有权的提案，而不会将这个明显的负担强加到普通的程序中去。</p>
<blockquote>
<p>译者注：这实在是一个好消息。</p>
</blockquote>
<p>独占性原则会引入一些新的静态和动态的限制。我们相信这些限制只会影响很小的一部分代码，而且这部分代码我们应该已经在文档中写明了可能产生非确定的结果。当我们进行动态限制的时候，还会造成一些性能上的损失。我们希望它所带来的优化潜力能够至少“弥补”这个损失。我们也会为程序员提供工具，来在必要的时候跳过这些安全检查。在文档后面的部分，我们会讨论很多这方面的限制。</p>
<h2 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h2><h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p>任何关于所有权系统的讨论都会基于更低的抽象层级。我们将要讨论的是一些语言实现方面的话题。在这个上下文中，当我们提到“值”这个词时，我们所表述的是具有特定语义的，用户口中的值的实例。</p>
<p>举例来说，下面的 Swift 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var x = [1,2,3]</div><div class="line">var y = x</div></pre></td></tr></table></figure>
<p>人们通常会说这里 <code>x</code> 和 <code>y</code> 具有相同的值。让我们把这种值称为<strong>语义值</strong>。但是在实现层面上，因为变量 <code>x</code> 和 <code>y</code> 是能被独立改变的，所以 <code>y</code> 的值必须是 <code>x</code> 的值的复制。我们把这个叫做<strong>值的实例</strong>。一个值实例可以保持不变，并在内存中到处移动，不过进行复制的话则一定会导致新的值实例。在这篇文档剩下的部分，当我们不加修饰地使用“值”这个词时，我们指的是值实例这种更低层级的表述。</p>
<p>复制和销毁一个值实例的意义，随着类型不同稍有区别：</p>
<ul>
<li><p>有些类型只需要按照字节表示进行操作，而不需要额外工作，我们将这种类型叫做<strong>平凡类型</strong> (trivial)。比如，<code>Int</code> 和 <code>Float</code> 就是平凡类型，那些只包含平凡值的 <code>struct</code> 或者 <code>enum</code> 也是平凡类型。我们在本文中关于所有权的大部分表述都不适用于这种类型的值。不过独占性原则在这里依然适用。</p>
</li>
<li><p>对于引用类型，值实例是一个对某个对象的引用。复制这个值实例意味着创建一个新的引用，这将使引用计数增加。销毁这个值实例意味着销毁一个引用，这会使引用计数减少。不断减少引用计数，最后当然它会变成 0，并导致对象被销毁。但是需要特别注意的是，我们这里谈到的复制和销毁值，只是对引用计数的操作，而不是复制或者销毁对象本身。</p>
</li>
<li><p>对于写时复制的类型，值实例中包含了一个指向内存缓冲区的引用，它的工作方式和引用类型基本相同。我们要再次提醒，复制值并不意味着将缓冲区中的内容复制到一个新的缓冲区中。</p>
</li>
</ul>
<p>对每种类型，使用的规则是相似的。</p>
<blockquote>
<p>译者注：在 Swift 中，值类型和引用类型的区别是相当重要的。当前 Swift 的最大的使用场景是和 Cocoa 框架合作制作 app，而 Cocoa 包括 Foundation 仍然是一个引用类型占主导地位的框架。值类型在 Swift 里使用非常广泛，你几乎很难避免混用两种类型。从 Swift 3 开始，开发团队正在将 Foundation 框架逐步转换为值类型 (比如 <code>NSURL</code> 到 <code>URL</code>，<code>NSData</code> 到 <code>Data</code> 的转换)，但是在底层它们包含了一个指向原来的对象类型的桥接。这就使得上面的最后一种情况 (写时复制类型) 变得非常普遍。另外，在我们自己创建的 Swift <code>struct</code> 和 <code>enum</code> 中，也经常会有引用类型作为成员的情况存在。而在这种情况下，写时复制并不是直接具备的特性，它需要我们进行额外的实现，否则我们就只能将它看作是引用类型来使用，否则很可能出现问题。在处理包含引用类型的值时，务必多多斟酌，特别小心。</p>
</blockquote>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>一般来说，一个值可以以两种方式中的一种被持有：它可能是“临时”的，也就是说一个特定的执行上下文对这个值进行了计算，并将它当作操作数；或者它可以是“静止”的，被存放在内存某处。</p>
<p>对于临时值，它们的所有权规则十分直接，我们无需多加关注。临时值是由一些表达式所创建的结果，这些表达式被用在特定的地方，而这些值也就只需要在被用在这些地方。所以语言实现需要做的事情就很清楚了：只需要完成将它们直接送到需要的地方就可以了，而不必强制对它们进行复制。用户已经明白会发生的是什么，因此这部分没有实际需要改进的必要。</p>
<p>那么，我们关于所有权的讨论将很大程度上围绕内存中保存的值来进行。在 Swift 中，关于对内存的处理，有五个紧密相关的概念。</p>
<p><strong>存储声明</strong> (storage declaration) 是一个语法概念，它声明了相关内存在这门语言里被处理的方式。现在，存储声明通过 <code>let</code>，<code>var</code> 和 <code>subscript</code> 引入。存储声明是带有类型的，它也包含了一些定义，来规定读取和写入存储时的方式。<code>var</code> 或者 <code>let</code> 的默认实现除了创建一个新变量来存储值以外并没有做什么。不过存储声明也可以是被计算出来的，也就是，并没有必要说一个变量背后一定会有对应的存储。</p>
<p><strong>存储引用表达式</strong> (storage reference expression) 也是一个语法概念，它是一个对存储进行引用的表达式。这个概念与其他语言的 “l-value” 比较相似，不过不同的是它不需要一定被用在赋值语句的左边，因为存储也可能是不变的。</p>
<blockquote>
<p>译者注：本文中会多次提到存储引用表达式，所以为了确保能理解什么是存储引用表达式，我在这里啰嗦几句。所谓的 l-value 表达式，指的是一个指向某个具体存储位置的表达式。在其他语言中，l-value 应该是可以被赋值的，而在 Swift 中，l-value 并不需要能被赋值，是因为有常量值的存在，存储将不会改变。举例来说，比如对某个点 <code>Ponit</code> 的坐标的访问表达式 <code>p.x</code> 就是一个存储引用表达式，它访问的是具体存储的 x 值。如果 <code>x</code> 是以 <code>var</code> 的形式声明的，那么它和其他语言的 “l-value” 就是等同的，如果 <code>x</code> 的定义方式是 <code>let</code>，则不可赋值，但这并不影响 <code>p.x</code> 作为存储引用表达式存在。另外，如果正方形有一个面积计算属性 <code>var area: Float { retrun side * side }</code>，<code>square.area</code> 则不是存储引用表达式，因为它求值后并不是对存储的引用。</p>
</blockquote>
<p><strong>存储引用</strong> (storage reference) 是一个语言语义的概念，它声明了一个指向特定存储的完全填满的引用。换句话说，它是存储引用表达式抽象求值后的结果，不过它并不会实际去访问存储。如果存储是一个成员，那么基本会包含值或是指向存储的引用。如果存储是一个下标 (subscript)，它将包含索引的值。比如，像是 <code>widgets[i].weight</code> 这样的存储引用表达式可能被抽象求值为下述存储引用：</p>
<ul>
<li>属性 <code>var weight: Double</code> 的存储</li>
<li>下标 <code>subscript(index: Int)</code> 在索引值 <code>19: Int</code> 位置的存储</li>
<li>本地变量 <code>var widgets: [Widget]</code> 的存储</li>
</ul>
<p><strong>变量</strong> 是一个语义概念，它指的是内存中存储一个值的唯一地点。变量不需要是可变的 (至少在我们的文档中它不需要可变)。通常来说，存储声明是变量被创建的原因，不过它们也会在内存中被动态地创建 (比如使用 <code>UnsafeRawPointer</code>)。变量总是属于某一个特定的类型，也有一定的<strong>生命周期</strong>，在编程语言中，生命周期是指从变量开始存在的时间点到它被销毁的时间点之间的时间。</p>
<p><strong>内存地址</strong> (memory location) 是指内存中一连串的可以被标记位置的范围。在 Swift 里，这里基本上是一个实现细节上的概念。Swift 不保证任意的变量会在它的生命周期中都保持在同一个内存地址上，Swift 甚至不能保证变量一定是被存储在内存地址上。但是也有将变量临时强制放置在一个不变的地址上的时候，比如以 <code>inout</code> 方式将变量传递给 <code>withUnsafeMutablePointer</code> 时就遵循这条规则。</p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>对于存储引用表达式的某种特定的求值被称为访问。访问的方式有三种：<strong>读取</strong>，<strong>赋值</strong>，以及<strong>修改</strong>。赋值和修改都是<strong>写操作</strong>，不同的是赋值会将原来的值完全替换掉，而不会去读取它。修改的话需要依赖旧值。</p>
<p>所有的存储引用表达式都可以基于表达式出现的上下文，被归类到这三种访问类型中的一种。需要注意，这种归类是表面上的工作：它只依赖于当前上下文的语义规则，而不会去在程序的更深层次进行考虑和分析，也不会关心动态行为。比如，通过 <code>inout</code> 参数传递的存储引用不会关心被调用者有没有实际使用当前值，也不关心到底有没有实施写操作或者只是简单地使用它，这个访问在调用者里总是会被判断为更改访问。</p>
<p>存储引用表达式的求值可以分为两个阶段：首先会求得一个存储引用，之后，对存储引用的访问会持续一段时间。这两个阶段通常是接连进行的，但是在复杂的情况下，它们也可以被分开单独执行，比如在 <code>inout</code> 参数不是调用的最后一个参数时，就会发生这种情况。阶段分离的目的是将访问的持续时间最小化，而同时保持适应 Swift 的从左到右的最容易进行扩展的求值规则。</p>
<blockquote>
<p>译者注：如果能够接受之前的五个概念的分别的话，将表达式的求值和使用 (对存储的访问) 过程分开处理也就是自然而然的事情了。虽然这让心智模型变得更加复杂，但是却能对应更多的使用情况，而且相对而言付出的代价可以接受。</p>
</blockquote>
<h2 id="独占性原则"><a href="#独占性原则" class="headerlink" title="独占性原则"></a>独占性原则</h2><p>建立起这些概念后，我们就能简要地提出这提案的第一个部分 - 独占性原则了。所谓独占性原则，是指：</p>
<blockquote>
<p>如果一个存储引用表达式的求值结果是一个由变量所实现的存储引用，那么对这个引用的访问的持续时间段，不应该与其他任何对这个相同变量的访问持续时间段产生重合，除非这两个访问都是读取访问。</p>
</blockquote>
<p>这里有一个地方故意说得比较模糊：这条原则只指出了访问“不应该”产生重合，但是它没有指出如何强制做到这一点。这是因为我们将对不同类型的存储使用不同的方法来强制这个机制。我们将在下一个大节里讨论那些机制。首先，我们想要谈一谈这条规则会带来的一些结果，以及我们满足这条规则所要使用的策略。</p>
<h3 id="独占性的持续时间"><a href="#独占性的持续时间" class="headerlink" title="独占性的持续时间"></a>独占性的持续时间</h3><p>独占性原则说的是访问在它们的持续时间内必须是独占的。这个持续时间是由导致该次访问的直接上下文所决定的。也就是说，这是程序的一种<strong>静态</strong>特性，而从介绍部分中我们知道，横在我们面前的安全问题是一个<strong>动态</strong>的问题。按照一般经验，我们知道使用静态的方式来解决动态问题往往只能在保守的范围内生效；在动态的程序中，肯定会存在方案失效的时候。所以，一个自然的问题是，在这里要如何才能让一个通用的原则生效。</p>
<p>举例来说，当我们用 <code>inout</code> 参数的方式来传递存储的时候，访问会贯穿与整个调用所持续的过程中。这需要调用方保证在调用过程中没有其他对这个存储进行访问。这么一刀切的手法会不会有点太过粗糙？因为毕竟在被调用的函数中可能会有很多地方其实并不会用到这个 <code>inout</code> 参数。也许我们应该在追踪 <code>inout</code> 参数的访问这件事情上再细一些，我们可以在被调用的函数中来进行追踪，而不是粗暴地在整个调用者上施加独占性原则。其实问题在于，这个想法实在是太动态了，所以我们很难为它提供一个高效的实现。</p>
<p>调用方的 <code>inout</code> 规则有一个关键的优点；对于被传递的存储到底是什么，调用方有着大量的信息。这意味着调用方规则通常能以纯静态的方式让独占性原则适用，而不必添加动态检查或是做一些猜疑性质的假设。比如，要是有一个函数调用了某个本地变量上的 <code>mutating</code> 方法 (<code>mutating</code> 方法实际做的就是将 <code>self</code> 作为 <code>inout</code> 参数传入)，除非变量被一个逃逸闭包 (escaping closure) 所捕获，否则函数就能轻而易举地检查每次对变量的访问，并确认这些访问和调用没有重叠，以此来保证满足独占性原则。不仅如此，这个保证还能被向下传递给被调用者，被调用者可以使用这些信息来证明它自己的访问是安全的。</p>
<blockquote>
<p>译者注：我们往往会认为实际工作中 <code>inout</code> 的使用非常罕见，这说明你忽视了 <code>mutating</code> 方法的实质就是 <code>inout</code> 参数调用。在标准库中，很多关于数组或者字典的变更的方法都是 <code>mutating</code> 的，也符合这个原则。</p>
</blockquote>
<p>相反，被调用方对于 <code>inout</code> 的规则却无法从这样的信息中受益：这些信息在调用发生的时候就被抛弃了。这就造成了我们在介绍一节中谈到的现今普遍的优化问题。比如，假设被调用者从参数加载了一个值，然后调用一个优化器无法进行推断的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">extension Array &#123;</div><div class="line">  mutating func organize(_ predicate: (Element) -&gt; Bool) &#123;</div><div class="line">    let first = self[0]</div><div class="line">    if !predicate(first) &#123; return &#125;</div><div class="line">    ...</div><div class="line">    // something here uses first</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在被调用方的规则下，优化器必须把 <code>self[0]</code> 的值复制到 <code>first</code> 中，因为它只能假设 <code>predicate</code> 有可能以某种形式改变 <code>self</code> 上绑定的值。在调用方规则下，优化器则能在数组没有被改变的时候，一直使用数组中的元素值，而不需要进行复制。</p>
<p>不仅如此，试想上面的例子里，如果要遵守被调用方规则的话，我们能写的代码会变为怎样呢？像这样的高阶操作不应该需要担忧调用者传入的 <code>predicate</code> 会以再入的方式改变数组。上面例子里，像使用本地变量 <code>first</code> 而不是反复地访问 <code>self[0]</code> 这样简单的实现选择，在语义上就会变得特别重要；而想要维护这种事情的难度是不可想象的。所以 Swift 库一般都禁止这种再入式的访问。不过，因为标准库并不能完全地阻止程序员这么做，所以实现必须在运行时做一些额外的工作，来确保这样的代码不会导致未定义的行为，或者是让整个进程发生错误。如果作出限制的话，这些限制只会作用于那些在良好书写的代码中本不应该出现的情况，所以对大多数程序员来说，并没有什么损失。</p>
<p>因此，这个提案提出了类似调用方的 <code>inout</code> 那样的访问持续时间的规则，它能让接下来的调用有机会被优化，同时保证需要付出的语义代价很小。</p>
<blockquote>
<p>译者注：也就是说，所需要修改的代码很少，代码“变丑”或者“变复杂”的程度在可控范围之内。</p>
</blockquote>
<h3 id="值和引用类型的构成"><a href="#值和引用类型的构成" class="headerlink" title="值和引用类型的构成"></a>值和引用类型的构成</h3><p>我们已经谈了很多关于<strong>变量</strong>的内容了。读者可能会想要知道，<strong>属性</strong> (property) 的情况是如何的。</p>
<p>在我们上面陈述的定义体系中，属性是一个存储声明，一个存储属性会在它的容器中创建一个对应的变量。对这个变量的访问显然需要遵守独占性原则，但是因为属性是被组织到一起放在一个容器中的，这会不会导致一些额外的限制？特别是独占性原则应不应该阻止那些对同一个变量或者值，但是是通过不同属性所进行的访问。</p>
<p>属性可以被分为三种类型：</p>
<ul>
<li>值类型的实例属性，</li>
<li>引用类型的实例属性，以及</li>
<li>在任意类型上的 <code>static</code> 和 <code>class</code> 属性。</li>
</ul>
<blockquote>
<p>译者注：相比于 Objective-C，Swift 中的属性似乎并不是特别明显。因为 Objective-C 毕竟有 <code>@property</code> 这种显式的方式声明属性，而在 Swift 中，写在具体类型而非方法中的“变量声明”将自动成为属性。</p>
</blockquote>
<p>我们提议总是将引用类型属性和 <code>static</code> 属性看作各自独立的属性，而在某个特定 (但是很重要) 的特殊情况以外，将值类型的属性当作是非独立的来进行处理。这可能会带来很大的限制，对为何这个提议是必要的，以及为什么我们对不同类型的属性加以区别，我们会详加说明。主要有三个原因。</p>
<h4 id="独立性和容器"><a href="#独立性和容器" class="headerlink" title="独立性和容器"></a>独立性和容器</h4><p>第一个原因和容器有关。</p>
<p>对值类型来说，访问单个的属性和访问值的整体都是可能的。显然，访问一个单个属性和访问值的整体是冲突的，因为访问值的整体其实就是同时访问这个值里所有的属性。举例来说，比如有一个变量 <code>p: Point</code> (这个变量并不需要是一个本地变量)，它包含三个存储属性 <code>x</code>，<code>y</code> 和 <code>z</code>。要是能够同时并且独立地改变 <code>p</code> 和 <code>p.x</code> 的话，独占性原则就会有一个巨大的漏洞。所以我们必须在这里强制独占性原则，我们有三个选择：</p>
<p>(在阅读关于强制适用独占性原则的部分后，再来看这节内容会更容易理解。)</p>
<p>第一种方法是简单地将 <code>p.x</code> 的访问也看作是对 <code>p</code> 的访问。这很巧妙地就将漏洞堵上了，因为我们对 <code>p</code> 所适用的独占性原则很自然地将冲突的访问排除了。但是这也同时将对于其他属性的同时访问给排除了，因为对 <code>p</code> 中其他属性的访问都会触发对 <code>p</code> 的访问，从而使独占性原则生效。 </p>
<p>另外两种方法需要让这种关系倒过来。我们可以将所有对单独的存储属性的独占性原则分离出来，而不是对整体值进行独占：对于 <code>p</code> 的访问会被看作是对 <code>p.x</code>，<code>p.y</code> 和 <code>p.z</code> 的方式。或者我们可以将独占性适用的方式参数化，并且记录正在被访问的属性的路径，比如 “”，”.x” 之类。不过，这些方式存在两个问题。</p>
<p>首先，我们并不总是知道全部的属性，或者那些属性是存储属性；某个类型的实现对我们来说有可能是不透明的，比如泛型或者还原的类型。对计算属性的访问必须被当作对整个值的访问，因为它需要将变量传递给 getter 或者 setter，而这些访问方法会是 <code>inout</code> 或者 <code>shared</code> 的。所以实际上它是和其他所有属性冲突的。使用动态的信息是可以让它们正常工作，但是这会在值类型的访问方法中引入很多记录方法，这和值类型被作为低耗费的抽象工具这一核心设计目标大相径庭。</p>
<p>其次，虽然这种模式可以相对容易地应用在独占性的静态适用上，但是想用在动态中就需要一大堆动态的记录，这也与我们的性能目标格格不入。</p>
<blockquote>
<p>译者注：这里考虑的属性访问路径和 Objective-C 的 KVC 有形似之处。不过这也正是 Swift 所极力避免避免的问题。类似这样的标注，或者说动态的修改，对于性能的损失是不可忽视的，在尽可能的情况下，我们都希望适用静态的方法来保证独占性。只有在确实无法静态决定的情况下，再使用动态方式。</p>
</blockquote>
<p>所以，虽然有方法能让我们将对不同的属性的访问和对整体值的访问独立开来，但是这要求我们强制对整体值使用独占性原则，而且还需要两种属性都是存储属性。虽然这是一种很重要的特殊情况，但是它也仅仅只是一种特殊情况。对于其他情况，我们必须回退到一般的规则，认为对于一个属性的访问同时也是对整体值的访问。</p>
<p>这些思考对于 <code>static</code> 属性以及引用类型的属性是不适用的。在 Swift 中没有同时访问一个类中所有属性的语言结构，而且说一个类型所有的 <code>static</code> 属性本身就是没有意义的事情，因为任何一个模块都能够在任何时候向某个类型添加 <code>static</code> 属性。</p>
<h4 id="独立访问的具体表现"><a href="#独立访问的具体表现" class="headerlink" title="独立访问的具体表现"></a>独立访问的具体表现</h4><p>第二个原因是基于用户期望的考虑。</p>
<p>避免对于不同属性的重叠访问最多只会造成一些小麻烦。在独占性原则下，我们至少可以避免“让人惊讶的长距离访问”：调用变量上的一个变量有可能开启一长串不明显的事件序列，然后最后返回并修改了原来的变量。现在有独占性原则，这就不会再发生了，因为这将会导致两个对同一变量互相冲突且重叠的访问。</p>
<p>作为对比，引用类型中有许多已经成为习惯的模式正是依赖这种“基于通知”的方式进行更新的。实际上，在 UI 代码中，同一个对象上的不同属性被并行修改并不是一件罕见的事儿：比如被用户 UI 操作修改的同时，被一些后台操作修改。阻止独立访问将会打破这种做法，这是无法接受的。</p>
<p>对于 <code>static</code> 属性，程序员期望它们是独立的全局变量；在一个全局变量被访问的时候，去禁止别的访问访问，这是说不通的。</p>
<h4 id="独立性和优化器"><a href="#独立性和优化器" class="headerlink" title="独立性和优化器"></a>独立性和优化器</h4><p>第三点和属性的优化潜力有关。</p>
<p>独占性原则的一部分目标是让一大类的优化能够适用于值。比如，值类型上的一个非 <code>mutating</code> 方法可以假设 <code>self</code> 在方法调用期间会完全保持一致。它不需要担心某个未知的函数会在调用期间返回并修改了 <code>self</code> 的值，因为这种修改将违背独占性原则。即使在 <code>mutating</code> 的方法中，除非知会这个方法，否则也没有其他代码能访问 <code>self</code>。这些假设对于优化 Swift 代码是非常关键的。</p>
<p>不过，这些假设一般来说对全局变量和引用类型属性的内容来说都不适用。类的引用可以被随意地共享，所以优化器必须假定某个未知方法可能会访问到同一个实例。另外，系统中的任何代码 (如果忽略访问权限控制的话) 都有可能访问到全局变量。所以就算将对不同属性的访问当作非独立的来对待，语言的实现能获得的好处也及其有限。</p>
<h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><p>虽然现在这门语言中在技术上来说下标从来不会是存储属性，但大多数的讨论对下标依然适用。通过下标访问值类型的一个部分和访问整个值是同等对待的，对和这个值的其他访问发生重叠的时候，也应如此考虑。这导致的最重要的结果就是两个不同的数组元素不能被同时访问。这会妨碍到某些操作数组时的通常做法，不过有些 (比如并行地改变一个数组的不同切片这类) 事情在 Swift 中本来就充满了问题。我们认为，通过有目的的对集合的 API 进行改进，可以将缓和所带来的主要影响。</p>
<blockquote>
<p>译者注：在日常开发中，对于数组的操作可能是并行编程中比较常见的多线程问题。在很大程度上，下标操作和实例属性的访问类似，我们可以通过加锁或者 GCD 做 barrier 的方式来确保数组线程安全。如果能在语言层面将独占性原则解决的话，将极大程度降低并行程序开发的难度。这也意味着今后的标准库中我们可以获得线程安全的数组，或者甚至整个标准库乃至第三方代码都会是默认线程安全的。</p>
</blockquote>
<h2 id="独占性原则的强制适用"><a href="#独占性原则的强制适用" class="headerlink" title="独占性原则的强制适用"></a>独占性原则的强制适用</h2><p>想要让独占性原则适用，我们有三种可行机制：静态强制，动态强制，以及未定义强制。所要选择的机制必须能由存储声明简单地决定，因为存储的定义和对它的所有直接的访问方法都必须满足声明的要求。一般来说，我们通过存储被声明为的类型，它的容器 (如果存在的话)，以及任何存在的声明标记 (比如 <code>var</code> 或者 <code>inout</code> 之类) 来决定适用哪种机制。</p>
<h3 id="静态强制"><a href="#静态强制" class="headerlink" title="静态强制"></a>静态强制</h3><p>在静态强制的机制下，编译器将检查独占性原则是否被违反，如果违反，则给出编译错误。因为这种方法安全可靠，并且不会产生运行时的损耗，所以应该是优先考虑的机制。</p>
<p>这种机制只能在所有东西都能被完美决定时使用。比如，对于值类型，因为独占性原则递归适用于所有属性，这保证了基本的存储是被独占访问的，所以独占性原则可以适用。对一般的引用类型则不适用，因为无法证明对于某个特定对象的引用是对这个对象的唯一的引用。不过，如果我们能够支持唯一引用的 class 类型的话，独占性原则就可以静态地适用它们的属性了。</p>
<p>在一些想定的情况下，编译器可能会为了保持源码兼容性和避免发生错误，从而隐式地插入复制操作。这应该只在需要源码兼容的模式下被使用。</p>
<blockquote>
<p>Swift 4 的路线图已经发布，主要会在 <code>String</code> 的部分引入部分的源码非兼容改动。同时 Swift 4 的编译器会支持通过特定的编译标记来在文件粒度上支持选择按 Swift 3 还是 Swift 4 进行编译。这种方式比现在 Swift 2.3 和 Swift 3 共存的方式要进步一些，不过也并不是说 Swift 4 就不用做迁移了…不过看情况似乎会比 2 到 3 的时候容易很多，因为至少我们可以做到一个文件一个文件进行迁移。</p>
</blockquote>
<p>静态强制会被用在：</p>
<ul>
<li><p>各类的非可变变量</p>
</li>
<li><p>本地变量，除非被闭包的使用影响 (之后会详述)</p>
</li>
<li><p><code>inout</code> 参数</p>
</li>
<li><p>值类型的实例属性</p>
</li>
</ul>
<h3 id="动态强制"><a href="#动态强制" class="headerlink" title="动态强制"></a>动态强制</h3><p>在动态强制下，语言实现将会维护一个记录，来确定每个变量现在是否正在被访问。如果发现冲突，它就将触发一个动态错误。如果编译器侦测到动态强制下一定会发现冲突的话，也可以由编译器给出一个静态错误。</p>
<p>进行记录时，对于每个变量需要两个 bit，将它标记为“未访问”，“读取”和“已修改”三种状态中的一种。虽然多个读取操作能够在同时一起生效，不过只要做法稍微聪明些，我们就可以通过在访问时将原来状态进行存储的方式，来避免对所有的访问进行完全的记录。</p>
<p>我们应该尽最大努力进行记录。这个做法需要能可靠地检测出那些必然会违反独占性原则的情况。我们没有要求它检测竞态条件 (race condition) 的状况，不过好消息是虽然没做要求，但它通常还是可以检测出竞态，这是一件好事。记录<strong>必须</strong>要能正确处理并行读取的情况，而不应该比如将记录永久地停在“读取”状态。但是，在并行读取时，即使是还有活动的读取者，将记录值设为“未读取”的状态却是可以接受的。这可以让记录使用非原子 (non-atomic) 操作。不过，在将一个类的不同属性的记录值打包到一个单独的字节时，却必须使用原子操作，因为在一个类中，对不同变量的并行访问是允许的。</p>
<blockquote>
<p>译者注：对于对 Objective-C 不熟悉的读者来说，原子操作和非原子操作可能是比较陌生的概念。原子操作指的是不会被线程调度机制打断的调用。比如在满足原子操作的 getter 中，同一个属性的 setter 被调用，那么 getter 还是能返回完整的正确值，但是非原子操作的属性则不具备这个特性，因此非原子要快得多。Swift 现在没有设置原子属性的语法，所有的属性默认都是非原子操作。如果需要在 Swift 中让属性满足原子操作，现在我们可能需要自行进行加/解锁。另外注意，原子/非原子操作和线程安全的程序并没有太大关系，它只是针对一个属性的一次读写操作所做的特性设定。</p>
</blockquote>
<p>当编译器检测到一个“实例内部”的访问时，也就是说在这种情况下，访问期间没有别的代码会执行，也就没有对同一个变量进行再入式访问的可能。此时，编译器就能避免更新记录的值，而只需要检查它现在是否具有一个恰当的值。这对读取来说很正常，因为读取操作往往只会在访问过程中复制值。当变量是 <code>private</code> 或者 <code>internal</code> 时，编译器可以检测到所有可能的访问都是内部访问，它就能够将所有的记录都去掉。我们希望这应该是非常常见的情形。</p>
<p>动态强制会被用在：</p>
<ul>
<li><p>使用了闭包，且有必要时的本地变量 (之后会详述)</p>
</li>
<li><p>class 类型的实例属性</p>
</li>
<li><p><code>static</code> 和 <code>class</code> 属性</p>
</li>
<li><p>全局变量</p>
</li>
</ul>
<p>我们需要为动态强制提供一个标注，来让它在特定的属性和类中降级去使用未定义强制的机制。当有人觉得动态强制的性能消耗太重时，这可以为他们提供一种将这个特性去除的方式。在独占性实现后的早期阶段，留有余地是尤其重要的，因为我们可能还在探索不同的实现方法，有可能还没有找到全面的优化方式。</p>
<p>在之后，我们可以对类实例进行隔离，这让我们可以对一些类实例的属性使用静态强制。</p>
<h3 id="未定义强制"><a href="#未定义强制" class="headerlink" title="未定义强制"></a>未定义强制</h3><p>未定义强制的意思是冲突既不会被静态检测，也不会被动态检测，冲突的结果将是未定义行为。对于 Swift “默认安全”的设计下的一般代码来说，这不是一个好的机制，但是这确实是像不安全指针 (unsafe pointer) 这类东西的唯一真正选择。</p>
<blockquote>
<p>译者注：<code>Unsafe</code> 家族继续在 Swift 中扮演垃圾桶角色。对于 C 的库，如果没有更好的替代，可能我们也只能接受牺牲安全性的事实。但是还是建议在真的要在 Swift 中使用 C 库之前，再三斟酌。诚然花力气去把 C 库用 Swift 进行重写不是一件很讨好的事情，但是还是应该在代码的安全特性和直接使用 C 库的便捷程度中进行权衡。如果选择使用 C 代码，建议尽量使用 struct 来进行一定的封装，避免过多地使用 Unsafe 类型来进行交互。</p>
</blockquote>
<p>未定义强制将被用于：</p>
<ul>
<li>不安全指针的 <code>memory</code> 属性。</li>
</ul>
<blockquote>
<p>译者注：Swift 1 和 2 里是 <code>memory</code> 属性，Swift 3 中应该已经被改名为 <code>pointee</code> 了。如果说是 Swift 团队又打算把它改回 <code>memory</code> 的话…我也很无语。希望只是原作者的笔误。</p>
</blockquote>
<h3 id="被闭包捕获的本地变量的独占性"><a href="#被闭包捕获的本地变量的独占性" class="headerlink" title="被闭包捕获的本地变量的独占性"></a>被闭包捕获的本地变量的独占性</h3><p>独占性原则的静态强制依赖于我们能够静态地知道对变量的使用发生在哪里。对于本地变量来说，这种分析通常都很直接，但是当一个变量被闭包所捕获后，控制流就会让使用情况变得难以理解，从而使整个事情变复杂。就算是非逃逸的闭包，也是有可能被重入或者并行执行的。对于闭包捕获的变量，我们采取以下原则：</p>
<ul>
<li><p>如果闭包 <code>C</code> 有可能逃逸，那么假设有被 <code>C</code> 捕获的任意变量 <code>V</code>，对 <code>V</code> 的有可能在一段逃逸时间后才被执行的访问 (也包括在 <code>C</code> 本身中的访问)，都必须遵守动态强制的原则，除非所有的访问都是读取访问。</p>
</li>
<li><p>如果闭包 <code>C</code> 不会逃逸出函数，那么它在函数内的使用地点都是已知的。在每处使用时，这个闭包要么被直接调用，要么被作为参数传递给另一个调用。对于每次这种调用时的非逃逸闭包，对每个被闭包 <code>C</code> 所捕获的变量 <code>V</code>，如果任意一个闭包含有对 <code>V</code> 的写操作，那这些闭包内的所有的访问都必须使用动态强制，并且这个闭包调用会被静态强制认为是试图对 <code>V</code> 进行写操作的调用。除此之外，所有的访问都可以使用静态强制，而且对闭包的调用会被视作对 <code>V</code> 的读取操作。</p>
</li>
</ul>
<p>可能这些规则会随着时间而逐渐改进。比如我们应该可以对闭包的直接调用的规则进行一些改善。</p>
<h2 id="所有权使用的具体的工具"><a href="#所有权使用的具体的工具" class="headerlink" title="所有权使用的具体的工具"></a>所有权使用的具体的工具</h2><h3 id="共享值"><a href="#共享值" class="headerlink" title="共享值"></a>共享值</h3><p>本章中的很多讨论里会出现一个新概念：<strong>共享值</strong> (shared value)。正如其名，共享值指的是一个被当前上下文和拥有它的另一部分程序所共享的值。因为程序的多个部分能够同时使用这个值，所以为了贯彻独占性原则，这个值对于所有上下文 (包括拥有这个值的上下文) 来说，都必须是只读的。这一概念可以使程序对值进行抽象，而不必对它们进行复制。这和 <code>inout</code> 可以让程序对变量进行抽象有异曲同工之妙。</p>
<blockquote>
<p>译者注：程序对值或者变量进行抽象可能不太容易理解。可以参考 <code>inout</code> 的实现方式，其实 <code>inout</code> 使程序在函数返回前对传入的参数进行赋值操作，就是一种抽象行为：这个关键字 <code>inout</code>，将传入变量且在返回时重新赋值变量这个操作，抽象为了一个修饰词。下述的 <code>shared</code> 与此类似，只不过它所抽象的目标对象是值。</p>
</blockquote>
<p>(熟悉 Rust 的读者可能会在共享值和 Rust 的不变借入 (immutable borrow) 的概念之间找到相似之处。)</p>
<blockquote>
<p>译者注：不愧是把大半个 Rust 团队挖过来了…本来还打算今年学一下 Rust，现在看来把 Swift 4 学好就行了…最近三年果然还是坚持了每年学一门新语言，它们分别叫 Swift 2，Swift 3 和 Swift 4。</p>
</blockquote>
<p>当一个共享值的源值是存储引用时，共享值实际上就是一个对存储的不可变引用。存储在共享值持续期间被作为读取操作进行访问，这样依赖，独占性原则会保证在访问期间不会有其他访问能对原来的变量进行修改。有些类型的共享值还可能被绑定到临时值上 (比如一个 r-value)。因为临时值总是被当前执行上下文所拥有，而且只在一个地方被使用，所以这不会带来额外的语义上的问题。</p>
<p>就像是普通的变量或者是 <code>let</code> 绑定时那样，我们可以在进行绑定后的作用域中使用共享值。如果要使用共享值的地方也要求所有权的话，Swift 将简单地对这个值进行隐式的赋值 - 这和普通的变量或者 <code>let</code> 绑定依然是一样的。</p>
<h4 id="共享值的局限"><a href="#共享值的局限" class="headerlink" title="共享值的局限"></a>共享值的局限</h4><p>文档的这个部分将描述几种生成和使用共享值的方式。不过，我们现在的设计还没有提供一个通用的，“一等公民”的机制来使用共享值。程序并不能返回一个共享值，不能构建一个共享值组成的数组，也不能将共享值存储为 <code>struct</code> 的字段等。这些限制和 <code>inout</code> 引用所存在的限制是相似的。事实上，它们之间的相似非常多，因此我们甚至可以引入一个术语来包含它们两者：我们将它们叫做<strong>暂态量</strong> (ephemerals)。</p>
<p>我们的设计没有给暂态量提供完备的支持，这是精心考量的决定，这主要是基于三点考虑：</p>
<ul>
<li><p>我们需要将这个提案的范围限制在未来几个月内可以确实实现的范围内。我们希望这个提案能给语言及其实现带来大量好处，但是提案本身已经涉及广阔，而且略有激进了。对暂态量的完整支持将会给实现和设计增加很多复杂度，这显然会导致提案超出预计范围。另外，余下的语言设计问题都很庞大，而且已经有几个现存的语言尝试了将暂态量作为一等特性，不过它们的结果并不能说完全令人满意。</p>
</li>
<li><p>类型系统是在复杂度与表述清晰度之间的权衡。只要将类型系统做得更复杂，你就总是能接受更多的程序，但是这并不一定是好的权衡。在像 Rust 这样的重视引用的语言中，背后的生命周期限定 (lifetime-qualification) 系统向用户模型中添加了很多复杂度。这些复杂度对用户来说确实成为了负担。而且它依然不可避免地时不时要回退到不安全的代码，来绕开所有权系统的一些限制。在当前看来，将作用域限定引入 Swift 并不是一个可以直接做出的决定。</p>
</li>
<li><p>在 Swift 中，一个类似 Rust 的生命周期 (作用域) 系统的功能并不需要像 Rust 中那样强大。Swift 有意地提供了一个让类型的作者和 Swift 编译器本身都能够保留很多实现自由度的语言模型。</p>
<p>比如，Swift 中的多态存储就比 Rust 的要灵活一些。Swift 里的 <code>MutableCollection</code> 会实现一个通过索引来访问元素的 <code>subscript</code> 下标方法，但是这个方法几乎可以以任何方式来进行实现并满足这个需求。如果有代码访问了这个 <code>subscript</code>，而它又正好是通过直接访问底层内存来实现的话，这个访问就将会发生在原地。但是如果 <code>subscript</code> 是以 getter 和 setter 的计算属性方式方式实现的话，访问将会发生在一个临时变量中，getter 和 setter 则会在需要时被调用。因为 Swift 的访问模型是高度词法化的，它保留了在访问的末端运行任意代码的可能性。想象一下，如果我们要实现一个循环，来将这些临时的可变引用添加到一个数组里，我们就需要在循环的每次迭代里都能把任意的代码添加到执行队列里，这样才能在函数操作完数组后进行清理工作。这肯定不会是一个低损耗的抽象！一个在生命周期规则下的，和 Rust 更相似的 <code>MutableCollection</code> 接口，需要保证 <code>subscript</code> 返回的是一个指向已存在的内存的指针；这样一来，下标就完全不能支持计算方式的实现了。</p>
<blockquote>
<p>译者注：Swift 的下标访问是一个很有意思的话题。与一般的值变量的复制行为不同，数组下标的访问正是直接的原地访问。但是这是借助于额外的地址器 (Addressors) 来完成的。在数组的下标方法中，并没有返回对应下标元素的值，而是返回了可以获取到元素值的更底层的访问方法 (accessor)。这样一来，写时复制的优化便可以对数组下标访问适用。而那些我们直接返回值的下标方法并不能从中获益，因为它们其实还是通过“计算”来返回下标访问，虽然这个计算本身仅仅只是返回了单个的值。有关更多地址器的问题，Swift 团队也有<a href="https://github.com/apple/swift/blob/master/docs/proposals/Accessors.rst#addressors" target="_blank" rel="external">详细的文档</a>进行介绍。</p>
</blockquote>
<p>对于简单的 <code>struct</code> 成员，也存在同样的问题。Rust 的生命周期规则中有这样规定：如果你有一个指向 <code>struct</code> 的指针，那么你可以创建一个指向该 <code>struct</code> 中的一个字段的指针，并且这个新指针会和原来的指针具有同样的生命周期。不过，这条规则不仅假定了字段是确实被存储在内存中的，而且假定了这个字段是被<strong>简单</strong>存储的，也就是说，你可以用一个简单的指针指向它，而且这个指针将满足所指向类型的指针的标准应用二进制接口 (Application Binary Interface, ABI)。这意味着 Rust 不能使用很多内存布局优化手段，比如像是将很多布尔字段打包到一个字节里，或者仅仅是减少某个字段的对齐方式等。我们不愿意将这种保证引入到 Swift 中。</p>
</li>
</ul>
<p>基于上述原因，虽然我们对进一步探索能够承载暂态值更多应用的更复杂的系统抱有理论上的兴趣，我们现在暂时并不打算进行相关的提案。因为这样一个系统所主要包含的是对类型系统的改变，所以我们并不担心这会在长期导致 ABI 稳定上的问题。我们也不用担心这会造成源码不兼容的情况。我们相信，关于这方面任何的增强都可以当作是对我们所提案的特性的扩展和推论来完成。</p>
<h3 id="本地暂态量绑定"><a href="#本地暂态量绑定" class="headerlink" title="本地暂态量绑定"></a>本地暂态量绑定</h3><p>在 Swift 中，对存储进行抽象，就只能将这个存储通过 <code>inout</code> 参数的方式传递，这是一个很蠢的限制。想要一个本地 <code>inout</code> 绑定的程序员，可以通过引入一个闭包，并且立即调用这个闭包的方式来轻易地绕开这个限制。这件原本是很简单的事情，不应该要如此麻烦才能达成。</p>
<p>共享值会让这个限制更加明显，用本地的共享值对一个本地的 <code>let</code> 值进行替换是一件很有意思的事情：共享值可以避免进行复制，而为此付出的代价是阻止其他的对原来存储的访问。我们不会鼓励程序员在他们的代码中通篇去使用 <code>shared</code> 来代替 <code>let</code>，特别是优化器通常都能够将复制操作给去除掉。但是，优化器也并不是永远都能移除复制操作，因此 <code>shared</code> 这个微优化在一些特定的情形下会很有用。而且，当与不可复制类型打交道时，去除掉正式的复制操作可能在语义上也是必要的。</p>
<p>我们提议直接去除掉这些限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inout root = &amp;tree.root</div><div class="line"></div><div class="line">shared elements = self.queue</div></pre></td></tr></table></figure>
<p>本地暂态量的初始赋值是必须的，而且它必须是一个存储引用表达式。对于这类值的访问持续到剩余作用域的结束。</p>
<blockquote>
<p>译者注：也就是说，让 <code>inout</code> 和 <code>shared</code> 的声明方式能够被一般程序员使用。不过其实对于绝大多数顶层应用的开发者来说，应该是不太用得到这两个声明关键字的。</p>
</blockquote>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数参数是程序里最重要的对值进行抽象的方式。Swift 现在提供三种方式的参数传递：</p>
<ul>
<li><p>通过具有所有权的值进行传递。这是一般参数的规则，我们无法显式地指明使用该方式。</p>
</li>
<li><p>通过共享的值进行传递。这是对 <code>nonmutating</code> 方法的 <code>self</code> 参数的规则，我们无法显式地指明使用该方式。</p>
</li>
<li><p>通过引用传递。这是对 <code>inout</code> 参数和 <code>mutating</code> 方法的 <code>self</code> 参数的规则。</p>
</li>
</ul>
<blockquote>
<p>译者注：没错，那些 <code>nonmutating</code> 的方法也具有 <code>self</code> 参数。(否则你就无法在方法内部使用 <code>self</code> 了！)</p>
</blockquote>
<p>我们提议，允许我们可以指明使用那些非标准的情况：</p>
<ul>
<li><p>函数的参数可以被显式指明为 <code>owned</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func append(_ values: owned [Element]) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This cannot be combined with <code>shared</code> or <code>inout</code>.</p>
<p><code>owned</code> 不能和 <code>shared</code> 或者 <code>inout</code> 一起使用。</p>
<p>它只是对默认情况的一种显式的表达。我们不应该希望用户经常把它们写出来，除非用户正在处理不可复制的类型。</p>
</li>
<li><p>函数的参数可以被显式指明为 <code>shared</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func ==(left: shared String, right: shared String) -&gt; Bool &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This cannot be combined with <code>owned</code> or <code>inout</code>.</p>
<p><code>shared</code> 不能和 <code>owned</code> 或 <code>inout</code> 一起使用。</p>
<p>如果函数参数是一个存储引用表达式的话，该存储在调用期间将被作为读取来进行访问。否则，参数表达式将被作为 r-value 来求值，并且临时值在调用中被共享。允许函数参数的临时值被共享是非常重要的，很多函数仅仅是因为自己事实上并不会去拥有参数，它们的参数就将被标记为 <code>shared</code>。而其实上，在语义上这些参数被作为对一个已存在的变量的引用时，才是标记 <code>shared</code> 的更为重要的情况。举个例子，我们这里将等号操作符的参数标为 <code>shared</code>，是因为它们需要在不事先声明的情况下，就能够对不可复制值也进行比较。同时，这也不能妨碍程序员去比较一般的字面值。</p>
<p>和 <code>inout</code> 一样，<code>shared</code> 是函数类型的一部分。不过与 <code>inout</code> 不同，大多数函数兼容性检查 (比如方法重写的检查和函数转换的检查) 在 <code>shared</code> 和 <code>owned</code> 不匹配时也应该成功。如果一个带有 <code>owned</code> 参数的函数被转换 (或是重写) 为了一个 <code>shared</code> 参数的函数，参数类型实际上必须是可复制的。</p>
</li>
<li><p>方法可以被显式声明为 <code>consuming</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">consuming func moveElements(into collection: inout [Element]) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这会使 <code>self</code> 被当作一个 <code>owned</code> 值传入，所以 <code>consuming</code> 不能和 <code>mutating</code> 或 <code>nonmutating</code> 混用。</p>
<p>在方法内，<code>self</code> 依然是一个不可变的绑定值。</p>
<blockquote>
<p>译者注：这里提出的 <code>consuming</code> 实际上是对 <code>mutating</code> 的一种更加严谨的细分。如果没有添加相应的约定，那么在使用 <code>mutating</code> 时，<code>self</code> 的独占性保证只能动态进行。而这也正是 <code>struct</code> 中 <code>mutating</code> 现在不受程序员待见的原因之一。</p>
</blockquote>
</li>
</ul>
<h3 id="函数结果"><a href="#函数结果" class="headerlink" title="函数结果"></a>函数结果</h3><p>我们在本节的开头进行过一些讨论，想要对 Swift 的词法访问模型进行扩展，让它能支持从函数中返回暂态量并不是一件容易的事。实现这样访问，需要在访问的开始和结束时都执行一些和存储相关的代码。而在一个函数返回后，访问其实就没有进一步执行代码的能力了。</p>
<p>当然了，我们可以返回一个包含暂态量的回调，然后等待调用者使用完这个暂态量后再调用回调，这样我们就能处理暂态量的存储代码了。然而，单单只是这样做还不够，因为被调用者有可能会依赖于它的调用者所做出的保证。举例来说，比如 <code>struct</code> 上的一个 <code>mutating</code>，它想要返回的是对一个存储属性的 <code>inout</code> 引用。想要一切正确，我们不仅要保证在访问属性后方法能够进行清理工作，还要保证绑定在 <code>self</code> 上的变量也一直有效。我们真正想要做的是在被调用侧以及调用侧所有有效的作用域内对当前上下文进行维护，并且简单地将暂态量作为参数，在调用侧进入一个新的嵌套的作用域。在编程语言中，这是一个已经被充分理解的情况了，那就是协程 (co-routine)。(因为作用域限制，你也可以将它想象为一个回调函数的语法糖，其中的 <code>return</code> 和 <code>break</code> 等都按照期望工作。)</p>
<p>事实上，协程可以用来解决很多有关暂态量的问题。我们会在接下来的几个子章节内探索这个问题。</p>
<blockquote>
<p>译者注：协程的概念可以帮助简化线程调度的问题，也是一个良好的异步编程模型的基础。</p>
</blockquote>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h3><p>和三种传递参数的方式相同，我们也可以将对一个序列进行循环的方式分为三种。每种方式都可以用一个 <code>for</code> 循环来表达。</p>
<h4 id="Consuming-迭代"><a href="#Consuming-迭代" class="headerlink" title="Consuming 迭代"></a>Consuming 迭代</h4><p>第一种迭代方式是 Swift 中我们已经很属性的方式了：消耗 (consuming) 迭代，这种迭代中每一步都由一个 <code>owned</code> 值来代表。这也是我们对那些值可能是按需生成的任意序列的唯一的迭代方式。对于不可复制类型的集合，这种迭代方式可以让集合最终被结构，同时循环将获取集合中元素的所有权。因为这种方式会取得序列所产生的值的所有权，而且任意一个序列都不能被多次迭代，所以对于 <code>Sequence</code> 来说，这是一个 <code>consuming</code> 操作。</p>
<p>我们可以显式地将迭代变量声明为 <code>owned</code> 来指明这种迭代方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for owned employee in company.employees &#123;</div><div class="line">  newCompany.employees.append(employee)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当非可变的迭代的要求不能被满足的时候，这种方式也应该被默认地使用。(而且，这也是保证源码兼容性所必须的。)</p>
<p>接下来两种方式只对集合有意义，而不适用于任意的序列。</p>
<blockquote>
<p>译者注：Swift 中，集合 (<code>Collection</code>) 一定是序列 (<code>Sequence</code>)，但是序列不一定是集合。</p>
</blockquote>
<h4 id="Non-mutating-迭代"><a href="#Non-mutating-迭代" class="headerlink" title="Non-mutating 迭代"></a>Non-mutating 迭代</h4><p>非可变迭代 (non-mutating iteration) 所做的事情是简单地访问集合中的每个元素，并且保持它们完好不变。这样，我们就不需要复制这些元素了；迭代变量可以简单地绑定给一个 <code>shared</code> 的值。这就是 <code>Collection</code> 上的 <code>nonmutating</code> 操作。</p>
<p>我们可以显式地将迭代变量声明为 <code>shared</code> 来指明这种迭代方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for shared employee in company.employees &#123;</div><div class="line">  if !employee.respected &#123; throw CatastrophicHRFailure() &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在序列类型满足 <code>Collection</code> 时，这种行为是默认行为，因为对于集合来说，这是一种更优化的做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for employee in company.employees &#123;</div><div class="line">  if !employee.respected &#123; throw CatastrophicHRFailure() &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果序列操作的是一个存储引用表达式的话，在循环持续过程中，存储会被访问。注意，这意味着独占性原则将隐式地保证在迭代期间集合不会被修改。程序可以对操作使用固有函数 (intrinsic function) <code>copy</code> 来显式地要求迭代作用在存储的复制值上。</p>
<blockquote>
<p>译者注：其实我们或多或少已经从 Swift 的值特性和独占性中获取好处了。比如对于一个可变数组，我们可以在迭代它的同时，修改它内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="keyword">for</span> v <span class="keyword">in</span> array &#123;</div><div class="line">   <span class="keyword">let</span> index = array.index(of: v)!</div><div class="line">   array.remove(at: index)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这正得益于对于迭代变量的复制，而这种操作在很多其他语言里是难以想象的。不过，这种语义上没有问题的做法却可能在实际中给程序员造成一些困扰。使用明确的标注来规范这种写法确实会是更好的选择。</p>
<p>关于固有函数，是指实现由编译器进行处理的那些“内嵌”在语言中的函数。我们会在后面的章节再进行详细说明。</p>
</blockquote>
<h4 id="Mutating-迭代"><a href="#Mutating-迭代" class="headerlink" title="Mutating 迭代"></a>Mutating 迭代</h4><p>一个可变迭代将访问每个元素，并且有可能对元素作出改变。所迭代的变量是一个对元素的 <code>inout</code> 引用。这是对 <code>MutableCollection</code> 的 <code>mutating</code> 操作。</p>
<p>这种方式必须显式地用 <code>inout</code> 来声明迭代变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for inout employee in company.employees &#123;</div><div class="line">  employee.respected = true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>序列操作的必须是一个存储引用表达式。在循环的持续时间中，存储将会被访问，和上面一种方式一样，这将阻止对于集合的重叠访问。(但是如果集合类型定义的操作是一个非可变操作的话，这条规则便不适用，比如一个引用语义的集合就是如此。)</p>
<h4 id="表达可变和不可变迭代"><a href="#表达可变和不可变迭代" class="headerlink" title="表达可变和不可变迭代"></a>表达可变和不可变迭代</h4><p>可变迭代和不可变迭代都要求集合在迭代的每一步创建一个暂态量。在 Swift 中，我们有若干种表达的方式，但是最合理的方式应该是使用协程。因为协程在为调用者产生 (yield) 值的时候不会丢弃自己的执行上下文，所以一个协程产生多个值就是很正常的用法了，这也非常符合循环的基本代码模式。由此产生的一类协程通常被称为生成器 (generator)，这也正是很多种主要语言实现迭代的方式。在 Swift 中，为了也能实现这种模式，我们需要允许对生成器函数进行定义，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mutating generator iterateMutable() -&gt; inout Element &#123;</div><div class="line">  var i = startIndex, e = endIndex</div><div class="line">  while i != e &#123;</div><div class="line">    yield &amp;self[i]</div><div class="line">    self.formIndex(after: &amp;i)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于使用者一方，用生成器来实现 <code>for</code> 循环的方式是很明显的；不过，如何直接在代码中允许生成器的使用却不那么明显的事情。如上所述，因为逻辑上整个协程必须运行在对原来值访问的作用域中，所以对于协程使用的方式，有一些有趣的限制。对于一般的生成器而言，如果生成器函数返回的确实是某种类型的生成器对象，那么编译器必须确保这个对象不会逃逸出访问范围。这是复杂度的一个重要来源。</p>
<h3 id="一般化的访问方法"><a href="#一般化的访问方法" class="headerlink" title="一般化的访问方法"></a>一般化的访问方法</h3><p>Swift 现在提供的用来获取属性和下标的工具相当粗糙：基本上只有 <code>get</code> 和 <code>set</code> 方法。对于性能很关键的任务来说，这些工具是远远不足的，因为它们并不支持直接对值进行访问，而一定会发生复制。标准库中可以使用稍微多一些的工具，可以在特定有限的情况下提供直接的访问，但是它们仍然很弱，而且基于不少原因，我们并不希望将它们暴露给用户。</p>
<p>所有权给我们提供了一个重新审视这个问题的机会，因为 <code>get</code> 返回的是一个拥有所有权的值，所以它无法用于那些不可复制类型。访问方法 (getter 或者 setter) 真正需要的是产生一个共享值的能力，而不只是单单能返回值。同样地，想要达成这一目的的一个可行方式是让访问方法能使用某种特殊的协程。和生成器不同，这个协程只能进行一次发生。而且我们没有必要为程序员设计调用它的方式，因为这种协程只会被用在访问方法中。</p>
<p>我们的想法是，不去定义 <code>get</code> 和 <code>set</code>，而是将在存储声明中定义 <code>read</code> 和 <code>modify</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var x: String</div><div class="line">var y: String</div><div class="line">var first: String &#123;</div><div class="line">  read &#123;</div><div class="line">    if x &lt; y &#123; yield x &#125;</div><div class="line">    else &#123; yield y &#125;</div><div class="line">  &#125;</div><div class="line">  modify &#123;</div><div class="line">    if x &lt; y &#123; yield &amp;x &#125;</div><div class="line">    else &#123; yield &amp;y &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个存储声明必须定义 <code>get</code> 或者 <code>read</code> (或者定义为存储属性) 中的一个，但是不应该进行同时定义。</p>
<p>如果想要可变的话，存储声明必须再定义 <code>set</code> 或者 <code>modify</code> 中的一个。不过也可以选择同时定义<strong>两者</strong>，这种情况下 <code>set</code> 会被用作赋值，而 <code>modify</code> 会被用作更改。这在优化某些复杂的计算属性时会很有用，因为它可以允许更改操作原地进行，而不用强制对首先读取的旧值进行重新赋值。不过，需要特别注意，<code>modify</code> 的行为必须和 <code>get</code> 和 <code>set</code> 的行为相一致。</p>
<h3 id="固有函数"><a href="#固有函数" class="headerlink" title="固有函数"></a>固有函数</h3><h4 id="move"><a href="#move" class="headerlink" title="move"></a><code>move</code></h4><p>Swift 优化器一般会尝试将值进行移动，而不是复制它们，但是强制进行移动也有其意义。正因如此，我们提议加入 <code>move</code> 函数。从概念上说，<code>move</code> 函数是一个 Swift 标准库的顶层函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func move&lt;T&gt;(_ value: T) -&gt; T &#123;</div><div class="line">  return value</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，这个函数有一些特定的含义。该函数不能被间接使用，参数表达式必须是某种形式的本地所有的存储：它可以是一个 <code>let</code>，一个 <code>var</code>，或者是一个 <code>inout</code> 的绑定。调用 <code>move</code> 函数在语义上等同将当前值从参数变量中移动出来，并将其以表达式制定的类型进行返回。返回的变量在最终初始化分析中将作为未初始化来对待。接下来变量所发生的事情依赖于变量的种类而定：</p>
<ul>
<li><p><code>var</code> 变量将被作为未初始化而简单传回。除非它被赋以新值或者被再次初始化，否则对它的使用都是非法的。</p>
</li>
<li><p><code>inout</code> 绑定和 <code>var</code> 类似，不过它不能在未初始化的情况下离开作用域。或者说，如果程序要离开一个有 <code>inout</code> 绑定的作用域的话，程序必须为这个变量赋新的值，而不论它是以何种方式离开作用域 (包括抛出错误的时候)。将 <code>inout</code> 暂时作为未定义变量的安全性是由独占性原则所保证的。</p>
</li>
<li><p><code>let</code> 变量不能被再次初始化，所以它不能再被使用。</p>
</li>
</ul>
<p>这对于现在的最终初始化分析是一个直接的补充，它能确保在使用一个本地变量之前，它总是被初始化过的。</p>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a><code>copy</code></h4><p><code>copy</code> 是 Swift 标准库中的一个顶层函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func copy&lt;T&gt;(_ value: T) -&gt; T &#123;</div><div class="line">  return value</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数必须是一个存储引用表达式。函数的语义和上面的代码一致：参数值会被返回。该函数的意义如下：</p>
<ul>
<li><p>它可以阻止语法上的特殊转换。举例来说，我们上面讨论过，如果 <code>shared</code> 参数是一个存储引用，那么存储在调用期间是被访问的。程序员可以通过事前在存储引用上调用 <code>copy</code> 来阻止这种访问，并且强制复制操作在函数调用前完成。</p>
</li>
<li><p>对于那些阻止隐式复制的类型来说，这是必须的。我们会对不可复制类型进行进一步叙述。</p>
</li>
</ul>
<h4 id="endScope"><a href="#endScope" class="headerlink" title="endScope"></a><code>endScope</code></h4><p><code>endScope</code> 是 Swift 标准库中的顶层函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func endScope&lt;T&gt;(_ value: T) -&gt; () &#123;&#125;</div></pre></td></tr></table></figure>
<p>参数必须是一个引用本地 <code>let</code>，<code>var</code> 或者独立的 (非参数，非循环) <code>inout</code> 或者 <code>shared</code> 声明。如果参数是 <code>let</code> 或者 <code>var</code>，则变量会被立即销毁。如果参数是 <code>inout</code> 或者 <code>shared</code>，则访问将立即终止。</p>
<p>最终初始化分析必须保证声明在这个调用后没有再被使用。如果存储是一个被逃逸闭包捕获的 <code>var</code> 的话，应该给出错误。</p>
<p>对于想要在控制流到达作用域结尾前就想要终止访问的情形来说，这很有用。同样地，对销毁值时的微优化也能起到作用。</p>
<p><code>enScope</code> 保证在调用的时候输入的值是被销毁的，或者对它的访问已经结束。不过它没有承诺这些事情确实发生在这个时间点：具体的实现仍然可以更早地结束它们。</p>
<h3 id="透镜-Lenses"><a href="#透镜-Lenses" class="headerlink" title="透镜 (Lenses)"></a>透镜 (Lenses)</h3><p>现在，Swift 中所有的存储引用表达式都是<strong>具体</strong>的：每一个组件都静态地对应一种存储声明。在社区中，大家在允许程序对存储进行抽象这件事上一致兴趣盎然，比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let prop = Widget.weight</div></pre></td></tr></table></figure>
<p>这里 <code>prop</code> 会是一个对 <code>weight</code> 属性的抽象引用，它的类型是 <code>(Widget) -&gt; Double</code>。</p>
<blockquote>
<p>译者注：对于类型上的方法来说，这种透镜抽象是一直存在的 - 因为方法不存在所有权的内存问题。</p>
</blockquote>
<p>这个特性和所有权模型有关，因为一个一般的函数的结果一定是一个 <code>owned</code> 的值：不会是 <code>shared</code>，也不是可变值。这意味着，上述这种透镜抽象只能抽象<strong>读操作</strong>，而不能对应<strong>写操作</strong>，而且我们只能为可复制的属性创建这种抽象。这也意味着使用透镜的代码会比使用具体存储引用的代码需要更多的复制。</p>
<p>设想，要是透镜抽象不是简单的函数，而是它们各自类型的值。那么透镜的使用将会变成一个对静态未知成员进行访问的抽象的存储引用表达式。这就需要语言的实现能够执行某种程度的动态访问。然而，访问未知的属性和访问实现未知的已知属性有几乎一样的问题；也就是说，为了实现泛型和还原类型，语言已经需要做类似的事情了。</p>
<p>总体来说，只要我们有所有权模型，这样的特性就正好可以符合我们的模型。</p>
<h2 id="不可复制的类型"><a href="#不可复制的类型" class="headerlink" title="不可复制的类型"></a>不可复制的类型</h2><p>不可复制的类型在很多高级的情况中会十分有用。比如，它们可以被用来高效地表达唯一的所有权。它们也可以用来表达一些含有像是原子类型这样的某种独立标识的值。它们还可以被用作一种正式的机制，来鼓励代码能够更高效地和那些复制起来开销很大的类型 (比如很大的) 一起使用。它们之间统一的主题是，我们不想类型被隐式地复制。</p>
<p>Swift 中处理不可复制类型的复杂度主要有两个来源：</p>
<ul>
<li><p>语言必须提供能将值进行移动和共享，而不强制进行复制的工具。我们已经对这些工具进行了提案，因为它们对优化可复制类型的使用也同等重要。</p>
</li>
<li><p>泛型系统必须能够表达不可复制的类型，同时不引入大量的源码兼容性问题，也不需要强制所有人使用不可复制类型。</p>
</li>
</ul>
<p>如果不是因为这两个原因的话，这个特性本身是很小的。就只需要用我们上面提到的 <code>move</code> 固有函数那样，隐式地使用移动来代替复制，并且在遇到无法适用的情况下给出诊断信息即可。</p>
<h3 id="moveonly-上下文"><a href="#moveonly-上下文" class="headerlink" title="moveonly 上下文"></a><code>moveonly</code> 上下文</h3><p>不过，泛型确实会是一个问题。在 Swift 中，最直白的为可复制特性建模的方式无非就是添加一个 <code>Copyable</code> 协议，让那些可以被复制的类型遵守这个协议。这样一来，不加限制的类型参数 <code>T</code> 就无法被假设为可复制类型。不过，这么做对源码兼容性和可用性来说都会是巨大的灾难，而且我们也不想让程序员在首次被介绍使用泛型代码的时候就去操心那些不可复制类型的问题。</p>
<p>另外，我们也不想让类型需要显式地被声明为支持 <code>Copyable</code>。对复制的支持应该是默认的。</p>
<p>所以，逻辑上来说解决的方式是，维持现在所有类型都是可复制类型的默认假设，然后允许上下文选择将这个假设关掉。我们将这些上下文叫做 <code>moveonly</code> 上下文。在一个 <code>moveonly</code> 上下文中词法嵌套的所有上下文也都隐式地成为 <code>moveonly</code>。</p>
<p>一个类型可以提供 <code>moveonly</code> 上下文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">moveonly struct Array&lt;Element&gt; &#123;</div><div class="line">  // Element and Array&lt;Element&gt; are not assumed to be copyable here</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将阻止在该类型声明，它的泛型参数 (如果有的话)，以及它们在继承链上所关联的类型上进行 <code>Copyable</code> 假设。</p>
<p>扩展也可以提供 <code>moveonly</code> 上下文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">moveonly extension Array &#123;</div><div class="line">  // Element and Array&lt;Element&gt; are not assumed to be copyable here</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过使用带有条件的协议遵守时，类型可以声明为条件可复制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">moveonly extension Array: Copyable where Element: Copyable &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不论是在约束条件里满足还是直接满足 <code>Copyable</code>，它都会是一个类型的继承特性，并且一定要在定义该类型的同一个模块中进行声明。(或者有可能的话，应该在同一个文件中进行声明。)</p>
<p>对于一个类型的非 <code>moveonly</code> 的扩展，将会把可复制性的假设重新引入这个类型及其泛型参数中。这么做的目的是为了标准库中的类型能够在不打破现有扩展的兼容性的同时，添加对不可复制元素的支持。如果一个类型没有进行任何的 <code>Copyable</code> 声明，那么为它添加一个非 <code>moveonly</code> 的扩展将会发生错误。</p>
<blockquote>
<p>译者注：这里的意思是，针对那些 <code>moveonly</code> 定义的类型，我们不能为它随意添加非 <code>moveonly</code> 的扩展。这是显而易见的，否则就会发生复制特性的冲突。而对于那些非 <code>moveonly</code> 的类型 (因为它们是隐式默认支持复制，或者说满足 <code>Copyable</code> 的)，以及在条件约束下满足 <code>Copyable</code> 的情况来说，添加非 <code>moveonly</code> 扩展是没有问题的。</p>
</blockquote>
<p>函数也可以定义一个 <code>moveonly</code> 上下文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extension Array &#123;</div><div class="line">  moveonly func report&lt;U&gt;(_ u: U)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将会使任何新的泛型参数和它们的继承关联类型上的复制假设无效。</p>
<p>很多关于 <code>moveonly</code> 上下文的细节我们扔在考虑之中。关于这个问题，在我们最终寻找到正确的设计之前，还需要很多的进行语言实现的经验。</p>
<p>我们正在考虑的一种可能性是，对于可复制类型的值，<code>moveonly</code> 上下文也将会取消其可复制假设。对于那些需要特别注意复制操作的代码来说，这会提供一种重要的优化工具。</p>
<h3 id="不可复制类型的-deinit"><a href="#不可复制类型的-deinit" class="headerlink" title="不可复制类型的 deinit"></a>不可复制类型的 <code>deinit</code></h3><p>对那些定义为 <code>moveonly</code> 的不遵守 (也不条件遵守) <code>Copyable</code> 的值类型，可以为其定义一个 <code>deinit</code> 方法。注意，<code>deinit</code> 必须被定义在类型的主定义域内，而不能定义在扩展中。</p>
<p>在值不再被需要时，<code>deinit</code> 将会被调用以销毁这个值。这让不可复制类型可以被用来表达对于资源的唯一所有权。比如说，这里有一个简单的处理文件的类型，它保证了值被销毁时，文件句柄一定会被关闭：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">moveonly struct File &#123;</div><div class="line">  var descriptor: Int32</div><div class="line"></div><div class="line">  init(filename: String) throws &#123;</div><div class="line">    descriptor = Darwin.open(filename, O_RDONLY)</div><div class="line"></div><div class="line">    // 在 `init` 里任何非正常退出都会阻止 deinit 被调用</div><div class="line">    if descriptor == -1 &#123; throw ... &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  deinit &#123;</div><div class="line">    _ = Darwin.close(descriptor)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  consuming func close() throws &#123;</div><div class="line">    if Darwin.fsync(descriptor) != 0 &#123; throw ... &#125;</div><div class="line"></div><div class="line">    // 这是一个 consuming 函数，所以它拥有对自己的所有权。</div><div class="line">    // 其他的任何方式都不会对 self 产生消耗，所以函数将在</div><div class="line">    // 退出时通过调用 deinit 进行销毁。</div><div class="line">    // 而 deinit 将会通过描述符实际关闭文件句柄。</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swift 对值的销毁 (以及对 <code>deinit</code> 的调用) 发生在一个值被最后使用后，以及正式解构的时间点前的期间内。不过这个定义中对于“使用”的定义暂时还没有完全决定。</p>
<p>如果这个值类型是一个 <code>struct</code>，那么 <code>deinit</code> 中 <code>self</code> 只能被用来引用类型的存储属性。<code>self</code> 的存储属性会被当作本地 <code>let</code> 常量被看待，并用于最终初始化分析；也就是说，它们是属于 <code>deinit</code> 方法，并且可以被移出去的。</p>
<p>如果值类型是一个 <code>enum</code> 的话，<code>deinit</code> 里的 <code>self</code> 只能被当作 <code>switch</code> 的操作数来使用。在 <code>switch</code> 内，任何一个用来初始化对应绑定的关联值，都拥有对这些值的所有权。这样的 <code>switch</code> 会使 <code>self</code> 处于未初始化状态。</p>
<h3 id="显式可复制类型"><a href="#显式可复制类型" class="headerlink" title="显式可复制类型"></a>显式可复制类型</h3><p>在不可复制类型里，还有一种我们在探索的想法，那就是将一个类型声明为不可被隐式复制。比如，一个很大的结构体可以被正式地进行复制，但是如果不必要地对它进行复制的话，就会对性能产生过大的影响。这样的类型应该需要遵守 <code>Copyable</code>，而且它应该在调用 <code>copy</code> 函数时请求一份复制。不过，编译器应当像在处理不可复制类型那样，在任何隐式复制发生时给出诊断信息。</p>
<h2 id="实现的优先级"><a href="#实现的优先级" class="headerlink" title="实现的优先级"></a>实现的优先级</h2><p>这篇文档陈列了很多工作，我们可以将其总结如下：</p>
<ul>
<li><p>强制独占性原则：</p>
<ul>
<li>静态强制</li>
<li>动态强制</li>
<li>动态强制的优化</li>
</ul>
</li>
<li><p>新的标注和声明：</p>
<ul>
<li><code>shared</code> 参数</li>
<li><code>consuming</code> 方法</li>
<li>本地 <code>shared</code> 和 <code>inout</code> 声明</li>
</ul>
</li>
<li><p>新的固有函数和它们的区别：</p>
<ul>
<li><code>move</code> 函数及其关联的影响</li>
<li><code>endScope</code> 函数及其关联的影响</li>
</ul>
</li>
<li><p>协程特性：</p>
<ul>
<li>通用的访问方法</li>
<li>生成器</li>
</ul>
</li>
<li><p>不可复制类型</p>
<ul>
<li>未来的设计工作</li>
<li>不可复制类型的区别</li>
<li><code>moveonly</code> 上下文</li>
</ul>
</li>
</ul>
<p>在接下来的版本中，最主要的目的是 ABI 稳定。对于这些特性的优先级划分和分析必须以它们对 ABI 的影响为中心。在将这一点纳入考虑后，我们主要对 ABI 方面有如下思考：</p>
<p>独占性原则将会改变对参数作出的保证，因此它将影响 ABI。我们必须在 ABI 锁定之前将这条规则纳入到语言中，否则我们将永远失去改变这个保守假设的机会。不过，除非我们打算将一部分工作放到运行时去做，否则具体的实现独占性原则的方式并不会对 ABI 产生影响。况且将部分工作放到运行时并不是必要的，它在未来的发布版本中也可以被改变。(另外需要说明，在技术上独占性原则可能给优化器造成重大的影响，但是这应该是一个普通的项目进程上的考虑，而不会影响到 ABI。)</p>
<blockquote>
<p>译者注：Swift 的 ABI 稳定是一个提了有两年的议题了。现在看来，Swift 4 中 ABI 稳定依然无法达成，也就是说不同 Swift 编译器编译出的二进制并不能互相通用 (举例来说，就是新版本 Swift 的 app 不能调用旧版本的 Swift 框架)。如果没有 ABI 稳定，Swift app 就还是必须包含 Swift 运行库的复制，我们也不可能使用二进制的框架。Apple 当前内部 app 和自己的框架几乎都不是 Swift 版本的，也在很大程度上受到 Swift ABI 稳定性的限制。</p>
</blockquote>
<p>标准库会积极地在参数上适配所有权标注。那些标注肯定会影响这些库的 ABI。库开发者需要时间来进行适配，更重要的是，它们需要一些方式来验证标注是有用的。不幸的是，用来验证的最好的方法是实现不可复制的类型，而这在优先级列表上是排名很低的任务。</p>
<p>通用的访问方法所需要的工作包括，将“最通用”的属性和下标标准访问方法从 <code>get</code>/<code>set</code>/<code>materializeForSet</code> 变更为 <code>read</code>/<code>set</code>/<code>modify</code>。这对所有的多态属性和下标访问都会带来 ABI 影响，所以它也必须先做。不过，这个 ABI 的变更可以在不实际将协程方式的访问方法引入 Swift 的前提下完成。重要的只是保证我们所使用的 ABI 在今后能够满足协程的要求。</p>
<p>生成器部分的工作可能会改变核心的集合协议。显然这会影响 ABI。和通用化的访问方法不同，我们绝对需要实现生成器，来让 ABI 满足我们的需求。</p>
<p>不可复制的类型和算法只会影响到标准库中对它们进行适配的范围的 ABI。如果库想要在标准的集合中对它们进行适配和扩展的话，就必须发生在 ABI 稳定之前。</p>
<p>新的本地声明和固有函数不会影响 ABI。(和大多数情况一下，影响最少的工作往往也是最简单的工作。)</p>
<p>看起来，想在标准库中适配所有权和不可复制类型，会有很多工作要做，但是这对不可复制类型的可用性来说十分重要。如果我们不能创建一个包含不可复制类型的 <code>Array</code> 的话，对语言来说，这将会是非常大的限制。</p>
<blockquote>
<p>译者注：长求总？好的，总结一下全文，<br>这个提案提出在今后的 Swift 版本 (极大可能是 Swift 4) 中引入如下变化：</p>
<ul>
<li>强制的独占性原则，违反该原则的代码将发生错误：<ul>
<li>如果在静态能检出违反独占性原则，则给出编译错误</li>
<li>如果在运行时动态检出违反独占性原则，则在违反时让代码崩溃</li>
<li>对于不安全指针的情况，独占性原则行为将是未定义</li>
</ul>
</li>
<li>添加 <code>shared</code>，<code>owned</code> 和 <code>consuming</code> 关键字<ul>
<li><code>shared</code> 用在参数或者声明上，表示不获取值的所有权，以此避免不必要的值复制。</li>
<li><code>owned</code> 和 <code>consuming</code> 分别用在变量和函数上，表示非 <code>shared</code> 方式的调用。</li>
</ul>
</li>
<li>增强访问方法，在 <code>get</code> 和 <code>set</code> 的基础上，添加 <code>read</code> 和 <code>modify</code> 方法。其中 <code>read</code> 对应 <code>shared</code> 参数，<code>modify</code> 对应 <code>inout</code>。</li>
<li>新的迭代方式，可以使用 <code>shared</code> 或 <code>inout</code> 来规定迭代变量的所有权。作为衍生，我们需要协程的方式进行实现。也就是说，可能会在语言中引入原生的生成器 (generator)。这也是进一步进行异步编程的基础，想要了解更多这方面内容，可以参看我的<a href="https://onevcat.com/2016/12/concurrency/" target="_blank" rel="external">另一篇博文</a>。</li>
<li>引入一系列所有权有关的固有函数，如 <code>move</code>，<code>copy</code> 和 <code>endScope</code>。它们为 Swift 的高级用户提供自行进行所有权管理的可能性。</li>
<li>对于不可复制的类型，引入 <code>moveonly</code> 来去除默认的可复制假设。</li>
</ul>
<p>另外，这篇宣言只是一些基础的设想和讨论。也就是说，有些细节，比如关键字的名字或者具体的实现方式还可能有变。不过，Swift 团队想要明确值的所有权的问题的方向应该是不变的。</p>
<p>通过这些新的手段和方式，我们可以厘清所有权，避免复制和进行相关优化，但是这并不意味着作为 Swift 的最终用户的程序员在开发时的写法会发生翻天覆地的变化。不过，理解 Swift 中值的所有权变化，可以让我们对这门语言的设计有更深的了解和思考。</p>
<p>如果你暂时无法理解和接受这些内容，在 Swift 4 发布后，我们应该可以获得更多面向语言的“使用者”的信息和例子，来帮助我们最终作出决定。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 团队最近在邮件列表里向社区发了一封邮件，讲述了关于内存所有权方面的一些未来的改变方向。作为上层 API 的使用者来说，我们可能并不需要了解背后所有的事实，但是 Apple 的这封邮件中对 Swift 的值和对象的内存管理进行了很全面的表述，一步步说明了前因后果。
    
    </summary>
    
    
      <category term="能工巧匠集" scheme="http://maxmak.tk/tags/%E8%83%BD%E5%B7%A5%E5%B7%A7%E5%8C%A0%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>使用邮件来进行信息管理，顺便介绍最近写的一个小 app - Mail Me</title>
    <link href="http://maxmak.tk/2017/02/22/2017-02-22-mailme-app/"/>
    <id>http://maxmak.tk/2017/02/22/2017-02-22-mailme-app/</id>
    <published>2017-02-21T17:05:00.000Z</published>
    <updated>2017-03-28T10:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>距离上一次自己在 App Store 发布个人 app 已经过去了两年多了。这段时间里把精力主要都放在了公司项目和继续进一步的学习中，倒也在日常工作和出书等方面取得了一些进展。个人 app 这块近两年虽然有写一些便捷的效率类应用，但是几次审核都被 Apple 无情拒掉以后，也就安心弄成自用的小工具了。看着自己逐渐发霉的开发者证书，果然觉得还是找时间倒腾点什么比较好。于是就有了现在想要介绍给大家的这个工具，<a href="https://mailmeapp.com" target="_blank" rel="external">Mail Me</a> - 一个可以帮助你快速给自己发送邮件的小 app。</p>
<h3 id="基于邮件的信息管理方式"><a href="#基于邮件的信息管理方式" class="headerlink" title="基于邮件的信息管理方式"></a>基于邮件的信息管理方式</h3><p>开发这个 app 的想法的来源也算偶然。去年初在 @Swift 大会上发现 <a href="https://www.objc.io" target="_blank" rel="external">objc.io</a> 的 <a href="https://twitter.com/chriseidhof" target="_blank" rel="external">Chris</a> 有一个很有趣的习惯，他会把我们谈话中提到的重要的事情不停地用邮件的方式发到自己的邮箱里。发送的内容包括像是对某个特性的讨论的结论，或是有疑问还等待确认的问题，甚至对那些他承诺了稍后再去深入研究的内容，也给自己发送了提醒。这样的收集信息的方式其实很有意思，相比与使用像是 To-Do 应用或者某些 GTD 的方式来说，似乎给自己发邮件这件事情并不那么 fashion。但是这将近一年来我也尝试了使用最基础的邮件对突发杂乱信息进行管理，发现效果很好。</p>
<p>最显而易见的好处是，使用邮件管理减轻了每天的信息获取负担。不论是公司业务还是开源项目，或者其他各种联络中，我对电子邮件的使用是绝对依赖的，收件箱也是我每天肯定会去检查好多次的地方。如果使用 To-Do 或者是专业的 GTD 应用，其实相当于给自己增加了额外的信息获取负担，并不高效，而且过程会更复杂。将待办事项通过邮件发给自己，可以在每次检查邮件时都看到，省去了确认和获取的环节，信息也相对更加集中。在事件结束后，及时将完成的事情归档，保持收件箱的干净。整个流程基本和一般的 GTD 思想一致，但是信息上下文不再被割裂，而是和邮件检查一同进行，保证效率。</p>
<p>不仅如此，其实我发现像是知识收集这样的事情用邮件来做也十分合适。我曾经是 Evernote 的粉丝，但是在 Evernote 越来越笨重而且基本没有我希望的功能后，我一直就在寻觅新的笔记软件。其间也尝试过 Simplenote 或者 Dropbox Paper 这类产品，但是总有些这样那样的不舒服。最后我选择了无数据库的方式，简单地用一个文件夹和 .md 文件来管理。这种方式显然是“纯天然”的笔记方式，但是不足也十分明显，那就是笔记内容难以组织和检索。而说到检索，映入脑海的首先就是 Google 这样的搜索引擎。如果我们的知识库能有 Google 这样的强力索引，那么之后的寻找和整理自然也不会是问题。万幸，在 Gmail 中，Google 就提供了一个同样强力的邮件搜索系统给我们使用。另外，邮箱系统强大的规则和分类，也为零散知识的自动归类整理提供了可能。于是我想，为什么不干脆直接用邮件来进行知识管理呢？</p>
<p>在这一年里，我把待办事项和知识管理的工作都交给了邮箱。将电子邮箱作为个人信息的中转和仓库，以发送给自己的邮件的方式来进行信息的管理。一年实践下来，我大概通过邮箱完成了上千的待办和接近 200 多条知识条目。对比起之前的方式，感觉节省下了不少时间。</p>
<p>在实践这种知识管理方法的过程中，最大的痛点在于我找不到一个能帮助我快速给自己发送邮件的客户端。在桌面系统上，macOS 自带的邮件客户端或者各类第三方 app 勉强可堪一用。另外，我也可以用像 Alfred 这类工具编写工作流，让我能迅速捕获信息，给自己发送邮件。但是在 iOS 上就更惨一些：我几乎每次都需要经历打开邮件客户端，等待启动，新建邮件，填写我自己的邮箱等这一系列步骤，才能开始给自己写邮件。每次重复这些无用的操作十分无趣，而且浪费时间。更麻烦的是，很可能你的操作速度赶不上思考或者和别人的交流速度，导致信息遗漏，甚至是打断思考的流程，这样就更得不偿失。而市面上的现有类似 app 功能都过于简单，且常年不更。所以我决定写一个专门给自己发送邮件的 app，以帮助我更好地实践邮件信息管理。</p>
<h3 id="使用-Mail-Me-帮助邮件信息管理"><a href="#使用-Mail-Me-帮助邮件信息管理" class="headerlink" title="使用 Mail Me 帮助邮件信息管理"></a>使用 Mail Me 帮助邮件信息管理</h3><p>这个 app 叫 Mail Me，顾名思义，它做的事情就是<strong>给自己发邮件</strong>。我同时使用 Mail Me 和 iOS 的邮件客户端进行了一些测试，想看看这款 app 能为我节省多少时间。</p>
<h4 id="一般编写-两倍速"><a href="#一般编写-两倍速" class="headerlink" title="一般编写 - 两倍速"></a>一般编写 - 两倍速</h4><p>Mail Me 的基本功能很简单，在配置后它将记下你的邮箱。之后你就可以简单地给自己发送邮件，而不必每次再填写自己的邮箱信息了。因为 Mail Me 是一个轻量级的应用，不存在邮箱客户端启动时代收邮件等工作，启动时间一秒不到。在 Mail Me 极简的界面中，你只需要集中精力编写内容，然后轻点发送，就可以给自己发送一封邮件了。一封提醒我下班后买牛奶回家的邮件从打开 app，输入内容，到发送完毕大约花费了我 8 秒时间。</p>
<video width="272" height="480" controls><br>  <source src="/assets/images/2017/mail-me-1.mp4" type="video/mp4"><br></video>

<p>而在系统邮件客户端中，除了等待打开以外，还需要经历输入发送目标，确认空白主题等一系列操作。就算在有收件人自动补全的情况下，在按下发送按钮时，就已经耗时 16 秒。</p>
<video width="272" height="480" controls><br>  <source src="/assets/images/2017/mail-me-2.mp4" type="video/mp4"><br></video>

<p>另外，除了立即发送以外，Mail Me 还支持延时发送。你可以指定一个未来的时间，Mail Me 将帮你预约邮件发送，这样你就能将邮件看作一个待办事项的提醒了。</p>
<h4 id="通知中心发送-五倍速"><a href="#通知中心发送-五倍速" class="headerlink" title="通知中心发送 - 五倍速"></a>通知中心发送 - 五倍速</h4><p>你也许会说，8 秒和 16 秒，又能有多少差距呢？确实，对于上面的情况，Mail Me 带来的速度优势并不足以产生决定性的影响，也许凑合使用系统邮件未尝不可。但是，通常情况下我们的使用场景是从兜里掏出手机，点亮屏幕，解锁手机，找到 app。加上这一系列操作后，可能使用系统邮箱 app 发送一封给自己的邮件就不是 16 秒，而是 30 秒以上了。如果你没有 Touch ID 帮助解锁的话，就还需要先输入手机密码，则整个过程更慢。</p>
<p>那么，我们来看看从锁屏界面开始，发送同样一封邮件，使用 Mail Me 会比原来慢多少呢？</p>
<video width="272" height="480" controls><br>  <source src="/assets/images/2017/mail-me-3.mp4" type="video/mp4"><br></video>

<p>慢多少？开玩笑吧，当然是会更快！实际的结果是，使用 Mail Me 我只花了 7 秒，比打开 app 进行一般编写的情况还要快上 1 秒 (没错就是启动时间)。在这种情况下 (也是我自己最经常使用的情况) Mail Me 要比打开邮件客户端快出 5 倍有余。</p>
<p>使用 Mail Me 可以直接从通知中心进行编写和发送，这对实践邮件信息管理提供了极大的便利。我相信直接在今日挂件里进行操作，真正做到了没有任何干扰，而是完全专注内容。你不需要在一大堆 app 图标里寻找需要的那个，在发送邮件之前也不会有任何多余动作。</p>
<p>另外，通知中心中还支持直接模板发送。如果你有想要多次发送的邮件，大可将其设置为模板，然后一次点击即可进行发送，更加方便。</p>
<h4 id="从其他-app-内发送-十倍速以上"><a href="#从其他-app-内发送-十倍速以上" class="headerlink" title="从其他 app 内发送 - 十倍速以上"></a>从其他 app 内发送 - 十倍速以上</h4><p>对于知识爆炸的现在，如何快速准确收集知识是十分重要的。Mail Me 对笔记和收集的场景当然也进行了一些对应，除了打开 app 和从通知中心发送，Mail Me 支持从其他 app 内直接发送邮件。比如你可以 Safari 里选择一段文字，并快速将文字内容和网页链接发送给自己；你也可以将通讯录里的联系人通过邮件的方式进行备忘。Mail Me 的快速发送支持几乎所有的文本格式，因此你可以在绝大部分带有分享功能的其他 app 中使用 Mail Me 给自己发送邮件。</p>
<video width="272" height="480" controls><br>    <source src="/assets/images/2017/mail-me-4.mp4" type="video/mp4"><br></video>

<p>我现在已经很难想像再用传统的邮件客户端完成这件事情了。我需要经历复制，退出当前 app，打开邮件客户端，新建邮件，输入自己的邮箱，选中文本编辑并长按，粘贴，最后发送这一系列噩梦。如果我想要保留一个出处的链接以供之后参考，我还需要再切回 Safari，复制地址，再切回邮件…大概这么折腾一下以后，当初收集知识的心已经完全被磨灭了吧…</p>
<h4 id="其他的注意事项"><a href="#其他的注意事项" class="headerlink" title="其他的注意事项"></a>其他的注意事项</h4><p>单独使用 Mail Me 来进行信息的管理已经可以节省不少时间，不过如果想要发挥这套邮件信息管理的全部潜力，则必须配合合适的邮箱规则。你可以对来自 Mail Me 的邮件进行归类，设置一些关键字或者按邮件标题分到不同的邮箱和邮箱文件夹中。如果你使用的邮箱是像 Gmail 那样拥有强大的索引和搜索功能的话，假以时日，建立一套完整的个人信息管理体制将轻而易举。</p>
<p>另外，在收集之后整理时，善用转发和回复，也可以将还不完善原件进行补充。而使用对话方式呈现的邮件及回复，可以说天然就是带有版本管理和 log 记录的信息流。这也有助于帮你回忆起所收集信息的前因后果。</p>
<h3 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h3><p>我花了一段时间尝试用邮件管理知识和待办，觉得很棒，而且现在也坚持在这样做。但是之前自己在 iPhone 上缺一个顺手的工具，所以就花空余时间撸了一个。然后估算了一下节省下来的时间，经过搜索，过去快一年间我大概给自己发送了 2000 封邮件，其中 1100 多个待办，200 多个知识条目，剩下 700 多是杂七杂八的普通邮件。那么，<strong>如果使用 Mail Me，相比下来节省的时间至少有 41500 秒</strong> (700 <em> (16 - 8) + 1100 </em> (30 - 7) + 200 <em> (60 - 7))，或者说 <em>*11.5 小时</em></em>。嗯…Mail Me 这个 app 的总开发时间可能都没有 11.5 小时，为什么我没有早一点想到写一个 app 来干这事儿呢。XD</p>
<p>不多说了，你可以在 <a href="https://mailmeapp.com" target="_blank" rel="external">Mail Me 的官方网站</a>找到一些其他信息，也可以直奔 <a href="https://itunes.apple.com/app/id1196289723?ls=1&amp;mt=8" target="_blank" rel="external">App Store 免费下载</a>这款应用。如果你对用邮件管理个人信息的方式感兴趣，并且想尝试一下的话，不妨可以试试 Mail Me 这款 app。(我在 app 里“无耻”地加了一个广告和内购，也希望能够把每年的开发者证书钱垫一下。) 另外，我计划在之后拿出一篇博文来简单说说在开发 Mail Me 的过程中值得一提的技术方面的一些小技巧，也欢迎大家继续关注。</p>
<p>那么，是时候给自己发封邮件提醒自己要好好休息一下了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离上一次自己在 App Store 发布个人 app 已经过去了两年多了。这段时间里把精力主要都放在了公司项目和继续进一步的学习中，倒也在日常工作和出书等方面取得了一些进展。个人 app 这块近两年虽然有写一些便捷的效率类应用，但是几次审核都被 Apple 无情拒掉以后，
    
    </summary>
    
    
      <category term="胡言乱语集" scheme="http://maxmak.tk/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Swift 并行编程现状和展望 - async/await 和参与者模式</title>
    <link href="http://maxmak.tk/2016/12/20/2016-12-20-concurrency/"/>
    <id>http://maxmak.tk/2016/12/20/2016-12-20-concurrency/</id>
    <published>2016-12-19T19:53:11.000Z</published>
    <updated>2017-03-28T10:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章不是针对当前版本 Swift 3 的，而是对预计于 2018 年发布的 Swift 5 的一些特性的猜想。如果两年后我还记得这篇文章，可能会回来更新一波。在此之前，请当作一篇对现代语言并行编程特性的不太严谨科普文来看待。</p>
</blockquote>
<p>CPU 速度已经很多年没有大的突破了，硬件行业更多地将重点放在多核心技术上，而与之对应，软件中并行编程的概念也越来越重要。如何利用多核心 CPU，以及拥有密集计算单元的 GPU，来进行快速的处理和计算，是很多开发者十分感兴趣的事情。在今年年初 Swift 4 的展望中，Swift 项目的负责人 Chris Lattern 表示可能并不会这么快提供语言层级的并行编程支持，不过最近 Chris 又在 IBM 的一次关于<a href="http://researcher.watson.ibm.com/researcher/files/us-lmandel/lattner.pdf" target="_blank" rel="external">编译器的分享</a>中明确提到，有很大可能会在 Swift 5 中添加语言级别的并行特性。</p>
<p><img src="/assets/images/2016/chris.jpg" alt=""></p>
<p>这对 Swift 生态是一个好消息，也是一个大消息。不过这其实并不是什么新鲜的事情，甚至可以说是一门现代语言发展的必经路径和必备特性。因为 Objective-C/Swift 现在缺乏这方面的内容，所以很多专注于 iOS 的开发者对并行编程会很陌生。我在这篇文章里结合 Swift 现状简单介绍了一些这门语言里并行编程可能的使用方式，希望能帮助大家初窥门径。(虽然我自己也还摸不到门径在何方…)</p>
<h2 id="Swift-现有的并行模型"><a href="#Swift-现有的并行模型" class="headerlink" title="Swift 现有的并行模型"></a>Swift 现有的并行模型</h2><p>Swift 现在没有语言层面的并行机制，不过我们确实有一些基于库的线程调度的方案，来进行并行操作。</p>
<h3 id="基于闭包的线程调度"><a href="#基于闭包的线程调度" class="headerlink" title="基于闭包的线程调度"></a>基于闭包的线程调度</h3><p>虽然恍如隔世，不过 GCD (Grand Central Dispatch) 确实是从 iOS 4 才开始走进我们的视野的。在 GCD 和 block 被加入之前，我们想要新开一个线程需要用到 <code>NSThread</code> 或者 <code>NSOperation</code>，然后使用 delegate 的方式来接收回调。这种书写方式太过古老，也相当麻烦，容易出错。GCD 为我们带来了一套很简单的 API，可以让我们在线程中进行调度。在很长一段时间里，这套 API 成为了 iOS 中多线程编程的主流方式。Swift 继承了这套 API，并且在 Swift 3 中将它们重新导入为了更符合 Swift 语法习惯的形式。现在我们可以将一个操作很容易地派发到后台进行，首先创建一个后台队列，然后调用 <code>async</code> 并传入需要执行的闭包即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> backgroundQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.onevcat.concurrency.backgroundQueue"</span>)</div><div class="line">backgroundQueue.async &#123;</div><div class="line">    <span class="keyword">let</span> result = <span class="number">1</span> + <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>async</code> 的闭包中，我们还可以继续进行派发，最常见的用法就是开一个后台线程进行耗时操作 (从网络获取数据，或者 I/O 等)，然后在数据准备完成后，回到主线程更新 UI：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> backgroundQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.onevcat.concurrency.backgroundQueue"</span>)</div><div class="line">backgroundQueue.async &#123;</div><div class="line">    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://api.onevcat.com/users/onevcat"</span>)!</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: url) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> user = <span class="type">User</span>(data: data)</div><div class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</div><div class="line">        <span class="keyword">self</span>.userView.nameLabel.text = user.name</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，现在估计已经不会有人再这么做网络请求了。我们可以使用专门的 <code>URLSession</code> 来进行访问。<code>URLSession</code> 和对应的 <code>dataTask</code> 会将网络请求派发到后台线程，我们不再需要显式对其指定。不过更新 UI 的工作还是需要回到主线程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://api.onevcat.com/users/onevcat"</span>)!</div><div class="line"><span class="type">URLSession</span>.shared.dataTask(with: url) &#123; (data, res, err) <span class="keyword">in</span></div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: url) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> user = <span class="type">User</span>(data: data)</div><div class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</div><div class="line">        <span class="keyword">self</span>.userView.nameLabel.text = user.name</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;.resume()</div></pre></td></tr></table></figure>
<h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><p>基于闭包模型的方式，不论是直接派发还是通过 <code>URLSession</code> 的封装进行操作，都面临一个严重的问题。这个问题最早在 JavaScript 中臭名昭著，那就是回调地狱 (callback hell)。</p>
<p>试想一下我们如果有一系列需要依次进行的网络操作：先进行登录，然后使用返回的 token 获取用户信息，接下来通过用户 ID 获取好友列表，最后对某个好友点赞。使用传统的闭包方式，这段代码会是这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="type">LoginRequest</span>(userName: <span class="string">"onevcat"</span>, password: <span class="string">"123"</span>).send() &#123; token, err <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> token = token &#123;</div><div class="line">        <span class="type">UserProfileRequest</span>(token: token).send() &#123; user, err <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> user = user &#123;</div><div class="line">                <span class="type">GetFriendListRequest</span>(user: user).send() &#123; friends, err <span class="keyword">in</span></div><div class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> friends = friends &#123;</div><div class="line">                        <span class="type">LikeFriendRequest</span>(target: friends.first).send() &#123; result, err <span class="keyword">in</span></div><div class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> result = result, result &#123;</div><div class="line">                                <span class="built_in">print</span>(<span class="string">"Success"</span>)</div><div class="line">                                <span class="keyword">self</span>.updateUI()</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(err)</span>"</span>)</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(err)</span>"</span>)                    </div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(err)</span>"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(err)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这已经是使用了尾随闭包特性简化后的代码了，如果使用完整的闭包形式的话，你会看到一大堆 <code>})</code> 堆叠起来。<code>else</code> 路径上几乎不可能确定对应关系，而对于成功的代码路径来说，你也需要很多额外的精力来理解这些代码。一旦这种基于闭包的回调太多，并嵌套起来，阅读它们的时候就好似身陷地狱。</p>
<p><img src="/assets/images/2016/confused.jpg" alt=""></p>
<p>不幸的是，在 Cocoa 框架中我们似乎对此没太多好办法。不过我们确实有很多方法来解决回调地狱的问题，其中最成功的应该是 Promise 或者 Future 的方案。</p>
<h3 id="Promise-Future"><a href="#Promise-Future" class="headerlink" title="Promise/Future"></a>Promise/Future</h3><p>在深入 Promise 或 Future 之前，我们先来将上面的回调做一些整理。可以看到，所有的请求在回调时都包含了两个输入值，一个是像 <code>token</code>，<code>user</code> 这样我们接下来会使用到的结果，另一个是代表错误的 <code>err</code>。我们可以创建一个泛型类型来代表它们：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">case</span> success(<span class="type">T</span>)</div><div class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重构 <code>send</code> 方法接收的回调类型后，上面的 API 调用就可以变为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="type">LoginRequest</span>(userName: <span class="string">"onevcat"</span>, password: <span class="string">"123"</span>).send() &#123; result <span class="keyword">in</span></div><div class="line">    <span class="keyword">switch</span> result &#123;</div><div class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> token):</div><div class="line">        <span class="type">UserProfileRequest</span>(token: token).send() &#123; result <span class="keyword">in</span></div><div class="line">            <span class="keyword">switch</span> result &#123;</div><div class="line">            <span class="keyword">case</span> .success(<span class="keyword">let</span> user):</div><div class="line">               <span class="comment">// ...</span></div><div class="line">            <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</div><div class="line">                <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(error)</span>"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(error)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看起来并没有什么改善，对么？我们只不过使用一堆 <code>({})</code> 的地狱换成了 <code>switch...case</code> 的地狱。但是，我们如果将 request 包装一下，情况就会完全不同。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Promise</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">init</span>(resolvers: (<span class="number">_</span> fulfill: @escaping (<span class="type">T</span>) -&gt; <span class="type">Void</span>, <span class="number">_</span> reject: @escaping (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="comment">// 存储 fulfill 和 reject。</span></div><div class="line">        <span class="comment">// 当 fulfill 被调用时解析为 then；当 reject 被调用时解析为 error。</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 存储的 then 方法，调用者提供的参数闭包将在 fulfill 时调用</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">then</span>&lt;U&gt;<span class="params">(<span class="number">_</span> body: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">U</span>&gt; &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">U</span>&gt;&#123;</div><div class="line">            <span class="comment">//...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 调用者提供该方法，参数闭包当 reject 时调用</span></div><div class="line">    <span class="function"><span class="keyword">func</span> `<span class="title">catch</span>`&lt;Error&gt;<span class="params">(<span class="number">_</span> body: <span class="params">(Error)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> promise: <span class="type">Promise</span>&lt;<span class="type">Response</span>&gt; &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">Response</span>&gt; &#123; fulfill, reject <span class="keyword">in</span></div><div class="line">            <span class="keyword">self</span>.send() &#123; result <span class="keyword">in</span></div><div class="line">                <span class="keyword">switch</span> result &#123;</div><div class="line">                <span class="keyword">case</span> .success(<span class="keyword">let</span> r): fulfill(r)</div><div class="line">                <span class="keyword">case</span> .failure(<span class="keyword">let</span> e): reject(e)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们这里没有给出 <code>Promise</code> 的具体实现，而只是给出了概念性的说明。<code>Promise</code> 是一个泛型类型，它的初始化方法接受一个以 <code>fulfill</code> 和 <code>reject</code> 作为参数的函数作为参数 (一开始这可能有点拗口，你可以结合代码再读一次)。这个类型里还提供了 <code>then</code> 和 <code>catch</code> 方法，<code>then</code> 方法的参数是另一个闭包，在 <code>fulfill</code> 被调用时，我们可以执行这个闭包，并返回新的 <code>Promise</code> (之后会看到具体的使用例子)：而在 <code>reject</code> 被调用时，通过 <code>catch</code> 方法中断这个过程。</p>
<p>在接下来的 <code>Request</code> 的扩展中，我们定义了一个返回 <code>Promise</code> 的计算属性，它将初始化一个内容类型为 <code>Response</code> 的 <code>Promise</code> (这里的 <code>Response</code> 是定义在 <code>Request</code> 协议中的代表该请求对应的响应的类型，想了解更多相关的内容，可以看看我之前的一篇<a href="/2016/12/pop-cocoa-2/">使用面向协议编程</a>的文章)。我们在 <code>.success</code> 时调用 <code>fulfill</code>，在 <code>.failure</code> 时调用 <code>reject</code>。</p>
<p>现在，上面的回调地狱可以用 <code>then</code> 和 <code>catch</code> 的形式进行展平了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="type">LoginRequest</span>(userName: <span class="string">"onevcat"</span>, password: <span class="string">"123"</span>).promise</div><div class="line"> .then &#123; token <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="type">UserProfileRequest</span>(token: token).promise</div><div class="line">&#125;.then &#123; user <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="type">GetFriendListRequest</span>(user: user).promise</div><div class="line">&#125;.then &#123; friends <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="type">LikeFriendRequest</span>(target: friends.first).promise</div><div class="line">&#125;.then &#123; <span class="number">_</span> <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"Succeed!"</span>)</div><div class="line">    <span class="keyword">self</span>.updateUI()</div><div class="line">    <span class="comment">// 我们这里还需要在 Promise 中添加一个无返回的 then 的重载</span></div><div class="line">    <span class="comment">// 篇幅有限，略过</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;.<span class="keyword">catch</span> &#123; error <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(error)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Promise</code> 本质上就是一个对闭包或者说 <code>Result</code> 类型的封装，它将未来可能的结果所对应的闭包先存储起来，然后当确实得到结果 (比如网络请求返回) 的时候，再执行对应的闭包。通过使用 <code>then</code>，我们可以避免闭包的重叠嵌套，而是使用调用链的方式将异步操作串接起来。<code>Future</code> 和 <code>Promise</code> 其实是同样思想的不同命名，两者基本指代的是一件事儿。在 Swift 中，有一些封装得很好的第三方库，可以让我们以这样的方式来书写代码，<a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="external">PromiseKit</a> 和 <a href="https://github.com/Thomvis/BrightFutures" target="_blank" rel="external">BrightFutures</a> 就是其中的佼佼者，它们确实能帮助避免回调地狱的问题，让嵌套的异步代码变得整洁。</p>
<p><img src="/assets/images/2016/future.jpg" alt=""></p>
<h2 id="async-await，“串行”模式的异步编程"><a href="#async-await，“串行”模式的异步编程" class="headerlink" title="async/await，“串行”模式的异步编程"></a>async/await，“串行”模式的异步编程</h2><p>虽然 Promise/Future 的方式能解决一部分问题，但是我们看看上面的代码，依然有不少问题。</p>
<ol>
<li>我们用了很多并不直观的操作，对于每个 request，我们都生成了额外的 <code>Promise</code>，并用 <code>then</code> 串联。这些其实都是模板代码，应该可以被更好地解决。</li>
<li><p>各个 <code>then</code> 闭包中的值只在自己固定的作用域中有效，这有时候很不方便。比如如果我们的 <code>LikeFriend</code> 请求需要同时发送当前用户的 token 的话，我们只能在最外层添加临时变量来持有这些结果：</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myToken: <span class="type">String</span> = <span class="string">""</span></div><div class="line"><span class="type">LoginRequest</span>(userName: <span class="string">"onevcat"</span>, password: <span class="string">"123"</span>).promise</div><div class="line"> .then &#123; token <span class="keyword">in</span></div><div class="line">    myToken = token</div><div class="line">    <span class="keyword">return</span> <span class="type">UserProfileRequest</span>(token: token).promise</div><div class="line">&#125; <span class="comment">//...</span></div><div class="line">.then &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Token is <span class="subst">\(myToken)</span>"</span>)</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>Swift 内建的 throw 的错误处理方式并不能很好地和这里的 <code>Result</code> 和 <code>catch { error in ... }</code> 的方式合作。Swift throw 是一种同步的错误处理方式，如果想要在异步世界中使用这种的话，会显得格格不入。语法上有不少理解的困难，代码也会迅速变得十分丑陋。</li>
</ol>
<p>如果从语言层面着手的话，这些问题都是可以被解决的。如果对微软技术栈有所关心的同学应该知道，早在 2012 年 C# 5.0  发布时，就包含了一个让业界惊为天人的特性，那就是 <code>async</code> 和 <code>await</code> 关键字。这两个关键字可以让我们用类似同步的书写方式来写异步代码，这让思维模型变得十分简单。Swift 5 中有望引入类似的语法结构，如果我们有 async/await，我们上面的例子将会变成这样的形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">bunttonPressed</span><span class="params">(<span class="number">_</span> sender: Any?)</span></span> &#123;</div><div class="line">    <span class="comment">// 1</span></div><div class="line">    doSomething()</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Button Pressed"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line">async <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Doing something..."</span>)</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 3</span></div><div class="line">        <span class="keyword">let</span> token   = await <span class="type">LoginRequest</span>(userName: <span class="string">"onevcat"</span>, password: <span class="string">"123"</span>).sendAsync()</div><div class="line">        <span class="keyword">let</span> user    = await <span class="type">UserProfileRequest</span>(token: token).sendAsync()</div><div class="line">        <span class="keyword">let</span> friends = await <span class="type">GetFriendListRequest</span>(user: user).sendAsync()</div><div class="line">        <span class="keyword">let</span> result  = await <span class="type">LikeFriendRequest</span>(target: friends.first).sendAsync()</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Finished"</span>)</div><div class="line">        </div><div class="line">        <span class="comment">// 4</span></div><div class="line">        updateUI()</div><div class="line">    &#125; <span class="keyword">catch</span> ... &#123;</div><div class="line">        <span class="comment">// 5</span></div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="comment">// 6</span></div><div class="line">    async <span class="function"><span class="keyword">func</span> <span class="title">sendAsync</span><span class="params">()</span></span> -&gt; <span class="type">Response</span> &#123;</div><div class="line">        <span class="keyword">let</span> dataTask = ...</div><div class="line">        <span class="keyword">let</span> data = await dataTask.resumeAsync()</div><div class="line">        <span class="keyword">return</span> <span class="type">Response</span>.parse(data: data)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，以上代码是根据现在 Swift 语法，对如果存在 <code>async</code> 和 <code>await</code> 时语言的形式的推测。虽然这不代表今后 Swift 中异步编程模型就是这样，或者说 <code>async</code> 和 <code>await</code> 就是这样使用，但是应该代表了一个被其他语言验证过的可行方向。</p>
</blockquote>
<p>按照注释的编号，进行一些简单的说明：</p>
<ol>
<li>这就是我们通常的 <code>@IBAction</code>，点击后执行 <code>doSomething</code>。</li>
<li><code>doSomething</code> 被 <code>async</code> 关键字修饰，表示这是一个异步方法。<code>async</code> 关键字所做的事情只有一件，那就是允许在这个方法内使用 <code>await</code> 关键字来等待一个长时间操作完成。在这个方法里的语句将被以同步方式执行，直到遇到第一个 <code>await</code>。控制台将会打印 “Doing something…”。</li>
<li>遇到的第一个 await。此时这个 <code>doSomething</code> 方法将进入等待状态，该方法将会“返回”，也即离开栈域。接下来 <code>bunttonPressed</code> 中 <code>doSomething</code> 调用之后的语句将被执行，控制台打印 “Button Pressed”。</li>
<li><code>token</code>，<code>user</code>，<code>friends</code> 和 <code>result</code> 将被依次 <code>await</code> 执行，直到获得最终结果，并进行 <code>updateUI</code>。</li>
<li>理论上 <code>await</code> 关键字在语义上应该包含 <code>throws</code>，所以我们需要将它们包裹在 <code>do...catch</code> 中，而且可以使用 Swift 内建的异常处理机制来对请求操作中发生的错误进行捕获和处理。换句话说，我们如果对错误不感兴趣，也可以使用类似 <code>try?</code> 和 <code>try!</code> 的</li>
<li>对于 <code>Request</code>，我们需要添加 <code>async</code> 版本的发送请求的方法。<code>dataTask</code> 的 <code>resumeAsync</code> 方法是在 Foundation 中针对内建异步编程所重写的版本。我们在此等待它的结果，然后将结果解析为 model 后返回。</li>
</ol>
<p>我们上面已经说过，可以将 <code>Promise</code> 看作是对 <code>Result</code> 的封装，而这里我们依然可以类比进行理解，将 <code>async</code> 看作是对 <code>Promise</code> 的封装。对于 <code>sendAsync</code> 方法，我们完全可以将它理解返回 <code>Promise</code>，只不过配合 <code>await</code>，这个 <code>Promise</code> 将直接以同步的方式被解包为结果。(或者说，<code>await</code> 是这样一个关键字，它可以等待 <code>Promise</code> 完成，并获取它的结果。)</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendAsync</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Promise</span>&lt;<span class="type">Response</span>&gt; &#123;</div><div class="line">   <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// await request.sendAsync()</span></div><div class="line"><span class="comment">// doABC()</span></div><div class="line"></div><div class="line"><span class="comment">// 等价于</span></div><div class="line"></div><div class="line">(<span class="keyword">try</span> request.sendAsync()).then &#123;</div><div class="line">    <span class="comment">// doABC()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不仅在网络请求中可以使用，对于所有的 I/O 操作，Cocoa 应当也会提供一套对应的异步 API。甚至于对于等待用户操作和输入，或者等待某个动画的结束，都是可以使用 <code>async/await</code> 的潜在场景。如果你对响应式编程有所了解的话，不难发现，其实响应式编程想要解决的就是异步代码难以维护的问题，而在使用 <code>async/await</code> 后，部分的异步代码可以变为以同步形式书写，这会让代码书写起来简单很多。</p>
<p>Swift 的 <code>async</code> 和 <code>await</code> 很可能将会是基于 <a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="external">Coroutine</a> 进行实现的。不过也有可能和 C# 类似，编译器通过将 <code>async</code> 和 <code>await</code> 的代码编译为带有状态机的片段，并进行调度。Swift 5 的预计发布时间会是 2018 年底，所以现在谈论这些技术细节可能还为时过早。</p>
<h2 id="参与者-actor-模型"><a href="#参与者-actor-模型" class="headerlink" title="参与者 (actor) 模型"></a>参与者 (actor) 模型</h2><p>讲了半天 <code>async</code> 和 <code>await</code>，它们所要解决的是异步编程的问题。而从异步编程到并行编程，我们还需要一步，那就是将多个异步操作组织起来同时进行。当然，我们可以简单地同时调用多个 <code>async</code> 方法来进行并行运算，或者是使用某些像是 GCD 里 <code>group</code> 之类的特殊语法来将复数个 <code>async</code> 打包放在一起进行调用。但是不论何种方式，都会面临一个问题，那就是这套方式使用的是命令式 (imperative) 的语法，而非描述性的 (declarative)，这将导致扩展起来相对困难。</p>
<p>并行编程相对复杂，而且与人类天生的思考方式相违背，所以我们希望尽可能让并行编程的模型保持简单，同时避免直接与线程或者调度这类事务打交道。基于这些考虑，Swift 很可能会参考 <a href="http://www.erlang.org" target="_blank" rel="external">Erlang</a> 和 <a href="http://akka.io" target="_blank" rel="external">AKKA</a> 中已经很成功的参与者模型 (actor model) 的方式实现并行编程，这样开发者将可以使用默认的分布式方式和描述性的语言来进行并行任务。</p>
<p>所谓参与者，是一种程序上的抽象概念，它被视为并发运算的基本单元。参与者能做的事情就是接收消息，并且基于收到的消息做某种运算。这和面向对象的想法有相似之处，一个对象也接收消息 (或者说，接受方法调用)，并且根据消息 (被调用的方法) 作出响应。它们之间最大的不同在于，参与者之间永远相互隔离，它们不会共享某块内存。一个参与者中的状态永远是私有的，它不能被另一个参与者改变。</p>
<p>和面向对象世界中“万物皆对象”的思想相同，参与者模式里，所有的东西也都是参与者。单个的参与者能力十分有限，不过我们可以创建一个参与者的“管理者”，或者叫做 actor system，它在接收到特定消息时可以创建新的参与者，并向它们发送消息。这些新的参与者将实际负责运算或者操作，在接到消息后根据自身的内部状态进行工作。在 Swift 5 中，可能会用下面的方式来定义一个参与者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Message</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> target: <span class="type">String</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line">actor <span class="type">NetworkRequestHandler</span> &#123;</div><div class="line">    <span class="keyword">var</span> localState: <span class="type">UserID</span></div><div class="line">    async <span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(connection: Connection)</span></span> &#123;</div><div class="line">       <span class="comment">// ...</span></div><div class="line">       <span class="comment">// 在这里你可以 await 一个耗时操作</span></div><div class="line">       <span class="comment">// 并改变 `localState` 或者向 system 发消息</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 3</span></div><div class="line">    message &#123;</div><div class="line">        <span class="type">Message</span>(<span class="keyword">let</span> m): processRequest(connection: <span class="type">Connection</span>(m.target))</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 4</span></div><div class="line"><span class="keyword">let</span> system = <span class="type">ActorSystem</span>(identifier: <span class="string">"MySystem"</span>)</div><div class="line"><span class="keyword">let</span> actor = system.actorOf&lt;<span class="type">NetworkRequestHandler</span>&gt;()</div><div class="line">actor.tell(<span class="type">Message</span>(target: <span class="string">"https://onevcat.com"</span>))</div></pre></td></tr></table></figure>
<blockquote>
<p>再次注意，这些代码只是对 Swift 5 中可能出现的参与者模式的一种猜想。最后的实现肯定会和这有所区别。不过如果 Swift 中要加入参与者，应该会和这里的表述类似。</p>
</blockquote>
<ol>
<li>这里的 <code>Message</code> 是我们定义的消息类型。</li>
<li>使用 <code>actor</code> 关键字来定义一个参与者模型，它其中包含了内部状态和异步操作，以及一个隐式的操作队列。</li>
<li>定义了这个 actor 需要接收的消息和需要作出的响应。</li>
<li>创建了一个 actor system (<code>ActorSystem</code> 这里没有给出实现，可能会包含在 Swift 标准库中)。然后创建了一个 <code>NetworkRequestHandler</code> 参与者，并向它发送一条消息。</li>
</ol>
<p>这个参与者封装了一个异步方法以及一个内部状态，另外，因为该参与者会使用一个自己的 DispatchQueue 以避免和其他线程共享状态。通过 actor system 进行创建，并在接收到某个消息后执行异步的运算方法，我们就可以很容易地写出并行处理的代码，而不必关心它们的内部状态和调度问题了。现在，你可以通过 <code>ActorSystem</code> 来创建很多参与者，然后发送不同消息给它们，并进行各自的操作。并行编程变得前所未有的简单。</p>
<p>参与者模式相比于传统的自己调度有两个显著的优点：</p>
<p>首先，因为参与者之间的通讯是消息发送，这意味着并行运算不必被局限在一个进程里，甚至不必局限在一台设备里。只要保证消息能够被发送 (比如使用 <a href="https://en.wikipedia.org/wiki/Inter-process_communication" target="_blank" rel="external">IPC</a> 或者 <a href="https://en.wikipedia.org/wiki/Direct_memory_access" target="_blank" rel="external">DMA</a>)，你就完全可以使用分布式的方式，使用多种设备 (多台电脑，或者多个 GPU) 进行并行操作，这带来的是无限可能的扩展性。</p>
<p>另外，由于参与者之间可以发送消息，那些操作发生异常的参与者有机会通知 system 自己的状态，而 actor system 也可以根据这个状态来重置这些出问题的参与者，或者甚至是无视它们并创建新的参与者继续任务。这使得整个参与者系统拥有“自愈”的能力，在传统并行编程中想要处理这件事情是非常困难的，而参与者模型的系统得益于此，可以最大限度保障系统的稳定性。</p>
<h2 id="这些东西有什么用"><a href="#这些东西有什么用" class="headerlink" title="这些东西有什么用"></a>这些东西有什么用</h2><p>两年下来，Swift 已经证明了自己是一门非常优秀的 app 语言。即使 Xcode 每日虐我千百遍，但是现在让我回去写 Objective-C 的话，我从内心是绝对抗拒的。Swift 的野心不仅于此，从 Swift 的开源和进化方向，我们很容易看出这门语言希望在服务器端也有所建树。而内建的异步支持以及参与者模式的并行编程，无疑会为 Swift 在服务器端的运用添加厚重的砝码。异步模型对写 app 也会有所帮助，更简化的控制流程以及隐藏起来的线程切换，会让我们写出更加简明优雅的代码。</p>
<p>C# 的 async/await 曾经为开发者们带来一股清流，Elixir 或者说 Erlang 可以说是世界上最优秀的并行编程语言，JVM 上的 AKKA 也正在支撑着无数的亿级服务。我很好奇当 Swift 遇到这一切的时候，它们之间的化学反应会迸发出怎样的火花。虽然每天还在 Swift 3 的世界中挣扎，但是我想我的心已经飞跃到 Swift 5 的并行世界中去了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章不是针对当前版本 Swift 3 的，而是对预计于 2018 年发布的 Swift 5 的一些特性的猜想。如果两年后我还记得这篇文章，可能会回来更新一波。在此之前，请当作一篇对现代语言并行编程特性的不太严谨科普文来看待。&lt;/p&gt;
&lt;/blo
    
    </summary>
    
    
      <category term="能工巧匠集" scheme="http://maxmak.tk/tags/%E8%83%BD%E5%B7%A5%E5%B7%A7%E5%8C%A0%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>面向协议编程与 Cocoa 的邂逅 (下)</title>
    <link href="http://maxmak.tk/2016/12/01/2016-12-01-pop-cocoa-2/"/>
    <id>http://maxmak.tk/2016/12/01/2016-12-01-pop-cocoa-2/</id>
    <published>2016-11-30T18:22:11.000Z</published>
    <updated>2017-03-28T10:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是笔者在 MDCC 16 (移动开发者大会) 上 iOS 专场中的主题演讲的文字整理。您可以在<a href="https://speakerdeck.com/onevcat/mian-xiang-xie-yi-bian-cheng-yu-cocoa-de-xie-hou" target="_blank" rel="external">这里</a>找到演讲使用的 Keynote，部分示例代码可以在 MDCC 2016 的<a href="https://github.com/MDCC2016/ProtocolNetwork" target="_blank" rel="external">官方 repo</a> 中找到。</p>
<p>在<a href="/2016/11/pop-cocoa-1/">上半部分</a>主要介绍了一些理论方面的内容，包括面向对象编程存在的问题，面向协议的基本概念和决策模型等。本文 (下) 主要展示了一些笔者日常使用面向协议思想和 Cocoa 开发结合的示例代码，并对其进行了一些解说。</p>
<h2 id="转・热恋-在日常开发中使用协议"><a href="#转・热恋-在日常开发中使用协议" class="headerlink" title="转・热恋 - 在日常开发中使用协议"></a>转・热恋 - 在日常开发中使用协议</h2><p>WWDC 2015 在 POP 方面有一个非常优秀的主题演讲：<a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="external">#408 Protocol-Oriented Programming in Swift</a>。Apple 的工程师通过举了画图表和排序两个例子，来阐释 POP 的思想。我们可以使用 POP 来解耦，通过组合的方式让代码有更好的重用性。不过在 #408 中，涉及的内容偏向理论，而我们每天的 app 开发更多的面临的还是和 Cocoa 框架打交道。在看过 #408 以后，我们就一直在思考，如何把 POP 的思想运用到日常的开发中？</p>
<p>我们在这个部分会举一个实际的例子，来看看 POP 是如何帮助我们写出更好的代码的。</p>
<h3 id="基于-Protocol-的网络请求"><a href="#基于-Protocol-的网络请求" class="headerlink" title="基于 Protocol 的网络请求"></a>基于 Protocol 的网络请求</h3><p>网络请求层是实践 POP 的一个理想场所。我们在接下的例子中将从零开始，用最简单的面向协议的方式先构建一个不那么完美的网络请求和模型层，它可能包含一些不合理的设计和耦合，但是却是初步最容易得到的结果。然后我们将逐步捋清各部分的所属，并用分离职责的方式来进行重构。最后我们会为这个网络请求层进行测试。通过这个例子，我希望能够设计出包括类型安全，解耦合，易于测试和良好的扩展性等诸多优秀特性在内的 POP 代码。</p>
<blockquote>
<p>Talk is cheap, show me the code.</p>
</blockquote>
<h4 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h4><p>首先，我们想要做的事情是从一个 API 请求一个 JSON，然后将它转换为 Swift 中可用的实例。作为例子的 API 非常简单，你可以直接访问 <a href="https://api.onevcat.com/users/onevcat" target="_blank" rel="external">https://api.onevcat.com/users/onevcat</a> 来查看返回：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"name"</span>:<span class="string">"onevcat"</span>,<span class="string">"message"</span>:<span class="string">"Welcome to MDCC 16!"</span>&#125;</div></pre></td></tr></table></figure>
<p>我们可以新建一个项目，并添加 <code>User.swift</code> 来作为模型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// User.swift</span></div><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">let</span> message: <span class="type">String</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>?(data: <span class="type">Data</span>) &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> obj = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: []) <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> name = obj?[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> message = obj?[<span class="string">"message"</span>] <span class="keyword">as</span>? <span class="type">String</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.name = name</div><div class="line">        <span class="keyword">self</span>.message = message</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>User.init(data:)</code> 将输入的数据 (从网络请求 API 获取) 解析为 JSON 对象，然后从中取出 <code>name</code> 和 <code>message</code>，并构建代表 API 返回的 <code>User</code> 实例，非常简单。</p>
<p>现在让我们来看看有趣的部分，也就是如何使用 POP 的方式从 URL 请求数据，并生成对应的 <code>User</code>。首先，我们可以创建一个 protocol 来代表请求。对于一个请求，我们需要知道它的请求路径，HTTP 方法，所需要的参数等信息。一开始这个协议可能是这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTPMethod</span>: <span class="title">String</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">GET</span></div><div class="line">    <span class="keyword">case</span> <span class="type">POST</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> host: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">var</span> path: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> method: <span class="type">HTTPMethod</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">var</span> parameter: [<span class="type">String</span>: <span class="type">Any</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将 <code>host</code> 和 <code>path</code> 拼接起来可以得到我们需要请求的 API 地址。为了简化，<code>HTTPMethod</code> 现在只包含了 <code>GET</code> 和 <code>POST</code> 两种请求方式，而在我们的例子中，我们只会使用到 <code>GET</code> 请求。</p>
<p>现在，可以新建一个 <code>UserRequest</code> 来实现 <code>Request</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserRequest</span>: <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    </div><div class="line">    <span class="keyword">let</span> host = <span class="string">"https://api.onevcat.com"</span></div><div class="line">    <span class="keyword">var</span> path: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"/users/<span class="subst">\(name)</span>"</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> method: <span class="type">HTTPMethod</span> = .<span class="type">GET</span></div><div class="line">    <span class="keyword">let</span> parameter: [<span class="type">String</span>: <span class="type">Any</span>] = [:]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UserRequest</code> 中有一个未定义初始值的 <code>name</code> 属性，其他的属性都是为了满足协议所定义的。因为请求的参数用户名 <code>name</code> 会通过 URL 进行传递，所以 <code>parameter</code> 是一个空字典就足够了。有了协议定义和一个满足定义的具体请求，现在我们需要发送请求。为了任意请求都可以通过同样的方法发送，我们将发送的方法定义在 <code>Request</code> 协议扩展上：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(handler: @escaping <span class="params">(User?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="comment">// ... send 的实现</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>send(handler:)</code> 的参数中，我们定义了可逃逸的 <code>(User?) -&gt; Void</code>，在请求完成后，我们调用这个 <code>handler</code> 方法来通知调用者请求是否完成，如果一切正常，则将一个 <code>User</code> 实例传回，否则传回 <code>nil</code>。</p>
<p>我们想要这个 <code>send</code> 方法对于所有的 <code>Request</code> 都通用，所以显然回调的参数类型不能是 <code>User</code>。通过在 <code>Request</code> 协议中添加一个关联类型，我们可以将回调参数进行抽象。在 <code>Request</code> 最后添加：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    associatedtype <span class="type">Response</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在 <code>UserRequest</code> 中，我们也相应地添加类型定义，以满足协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserRequest</span>: <span class="title">Request</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">typealias</span> <span class="type">Response</span> = <span class="type">User</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我们来重新实现 <code>send</code> 方法，现在，我们可以用 <code>Response</code> 代替具体的 <code>User</code>，让 <code>send</code> 一般化。我们这里使用 <code>URLSession</code> 来发送请求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(handler: @escaping <span class="params">(Response?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: host.appending(path))!</div><div class="line">        <span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: url)</div><div class="line">        request.httpMethod = method.rawValue</div><div class="line">        </div><div class="line">        <span class="comment">// 在示例中我们不需要 `httpBody`，实践中可能需要将 parameter 转为 data</span></div><div class="line">        <span class="comment">// request.httpBody = ...</span></div><div class="line">        </div><div class="line">        <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: request) &#123;</div><div class="line">            data, res, error <span class="keyword">in</span></div><div class="line">            <span class="comment">// 处理结果</span></div><div class="line">            <span class="built_in">print</span>(data)</div><div class="line">        &#125;</div><div class="line">        task.resume()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过拼接 <code>host</code> 和 <code>path</code>，可以得到 API 的 entry point。根据这个 URL 创建请求，进行配置，生成 data task 并将请求发送。剩下的工作就是将回调中的 <code>data</code> 转换为合适的对象类型，并调用 <code>handler</code> 通知外部调用者了。对于 <code>User</code> 我们知道可以使用 <code>User.init(data:)</code>，但是对于一般的 <code>Response</code>，我们还不知道要如何将数据转为模型。我们可以在 <code>Request</code> 里再定义一个 <code>parse(data:)</code> 方法，来要求满足该协议的具体类型提供合适的实现。这样一来，提供转换方法的任务就被“下放”到了 <code>UserRequest</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    associatedtype <span class="type">Response</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(data: Data)</span></span> -&gt; <span class="type">Response</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserRequest</span>: <span class="title">Request</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">typealias</span> <span class="type">Response</span> = <span class="type">User</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(data: Data)</span></span> -&gt; <span class="type">User</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">User</span>(data: data)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了将 <code>data</code> 转换为 <code>Response</code> 的方法后，我们就可以对请求的结果进行处理了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(handler: @escaping <span class="params">(Response?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: host.appending(path))!</div><div class="line">        <span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: url)</div><div class="line">        request.httpMethod = method.rawValue</div><div class="line">        </div><div class="line">        <span class="comment">// 在示例中我们不需要 `httpBody`，实践中可能需要将 parameter 转为 data</span></div><div class="line">        <span class="comment">// request.httpBody = ...</span></div><div class="line">        </div><div class="line">        <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: request) &#123;</div><div class="line">            data, <span class="number">_</span>, error <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> data = data, <span class="keyword">let</span> res = parse(data: data) &#123;</div><div class="line">                <span class="type">DispatchQueue</span>.main.async &#123; handler(res) &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="type">DispatchQueue</span>.main.async &#123; handler(<span class="literal">nil</span>) &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        task.resume()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我们来试试看请求一下这个 API：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> request = <span class="type">UserRequest</span>(name: <span class="string">"onevcat"</span>)</div><div class="line">request.send &#123; user <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> user = user &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(user.message)</span> from <span class="subst">\(user.name)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Welcome to MDCC 16! from onevcat</span></div></pre></td></tr></table></figure>
<h4 id="重构，关注点分离"><a href="#重构，关注点分离" class="headerlink" title="重构，关注点分离"></a>重构，关注点分离</h4><p>虽然能够实现需求，但是上面的实现可以说非常糟糕。让我们看看现在 <code>Request</code> 的定义和扩展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> host: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">var</span> path: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> method: <span class="type">HTTPMethod</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">var</span> parameter: [<span class="type">String</span>: <span class="type">Any</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">    </div><div class="line">    associatedtype <span class="type">Response</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(data: Data)</span></span> -&gt; <span class="type">Response</span>?</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(handler: @escaping <span class="params">(Response?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里最大的问题在于，<code>Request</code> 管理了太多的东西。一个 <code>Request</code> 应该做的事情应该仅仅是定义请求入口和期望的响应类型，而现在 <code>Request</code> 不光定义了 <code>host</code> 的值，还对如何解析数据了如指掌。最后 <code>send</code> 方法被绑死在了 <code>URLSession</code> 的实现上，而且是作为 <code>Request</code> 的一部分存在。这是很不合理的，因为这意味着我们无法在不更改请求的情况下更新发送请求的方式，它们被耦合在了一起。这样的结构让测试变得异常困难，我们可能需要通过 stub 和 mock 的方式对请求拦截，然后返回构造的数据，这会用到 <code>NSURLProtocol</code> 的内容，或者是引入一些第三方的测试框架，大大增加了项目的复杂度。在 Objective-C 时期这可能是一个可选项，但是在 Swift 的新时代，我们有好得多的方法来处理这件事情。</p>
<p>让我们开始着手重构刚才的代码，并为它们加上测试吧。首先我们将 <code>send(handler:)</code> 从 <code>Request</code> 分离出来。我们需要一个单独的类型来负责发送请求。这里基于 POP 的开发方式，我们从定义一个可以发送请求的协议开始：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(<span class="number">_</span> r: Request, handler: @escaping <span class="params">(Request.Response?)</span></span></span> -&gt; <span class="type">Void</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 编译错误</span></div></pre></td></tr></table></figure>
<p>从上面的声明从语义上来说是挺明确的，但是因为 <code>Request</code> 是含有关联类型的协议，所以它并不能作为独立的类型来使用，我们只能够将它作为类型约束，来限制输入参数 <code>request</code>。正确的声明方式应当是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span>&lt;T: Request&gt;<span class="params">(<span class="number">_</span> r: T, handler: @escaping <span class="params">(T.Response?)</span></span></span> -&gt; <span class="type">Void</span>)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> host: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了使用 <code>&lt;T: Request&gt;</code> 这个泛型方式以外，我们还将 <code>host</code> 从 <code>Request</code> 移动到了 <code>Client</code> 里，这是更适合它的地方。现在，我们可以把含有 <code>send</code> 的 <code>Request</code> 协议扩展删除，重新创建一个类型来满足 <code>Client</code> 了。和之前一样，它将使用 <code>URLSession</code> 来发送请求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">URLSessionClient</span>: <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> host = <span class="string">"https://api.onevcat.com"</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span>&lt;T: Request&gt;<span class="params">(<span class="number">_</span> r: T, handler: @escaping <span class="params">(T.Response?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: host.appending(r.path))!</div><div class="line">        <span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: url)</div><div class="line">        request.httpMethod = r.method.rawValue</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: request) &#123;</div><div class="line">            data, <span class="number">_</span>, error <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> data = data, <span class="keyword">let</span> res = r.parse(data: data) &#123;</div><div class="line">                <span class="type">DispatchQueue</span>.main.async &#123; handler(res) &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="type">DispatchQueue</span>.main.async &#123; handler(<span class="literal">nil</span>) &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        task.resume()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在发送请求的部分和请求本身分离开了，而且我们使用协议的方式定义了 <code>Client</code>。除了 <code>URLSessionClient</code> 以外，我们还可以使用任意的类型来满足这个协议，并发送请求。这样网络层的具体实现和请求本身就不再相关了，我们之后在测试的时候会进一步看到这么做所带来的好处。</p>
<p>现在这个的实现里还有一个问题，那就是 <code>Request</code> 的 <code>parse</code> 方法。请求不应该也不需要知道如何解析得到的数据，这项工作应该交给 <code>Response</code> 来做。而现在我们没有对 <code>Response</code> 进行任何限定。接下来我们将新增一个协议，满足这个协议的类型将知道如何将一个 <code>data</code> 转换为实际的类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Decodable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(data: Data)</span></span> -&gt; <span class="type">Self</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Decodable</code> 定义了一个静态的 <code>parse</code> 方法，现在我们需要在 <code>Request</code> 的 <code>Response</code> 关联类型中为它加上这个限制，这样我们可以保证所有的 <code>Response</code> 都可以对数据进行解析，原来 <code>Request</code> 中的 <code>parse</code> 声明也就可以移除了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最终的 Request 协议</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> path: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">var</span> method: <span class="type">HTTPMethod</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">var</span> parameter: [<span class="type">String</span>: <span class="type">Any</span>] &#123; <span class="keyword">get</span> &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// associatedtype Response</span></div><div class="line">    <span class="comment">// func parse(data: Data) -&gt; Response?</span></div><div class="line">    associatedtype <span class="type">Response</span>: <span class="type">Decodable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后要做的就是让 <code>User</code> 满足 <code>Decodable</code>，并且修改上面 <code>URLSessionClient</code> 的解析部分的代码，让它使用 <code>Response</code> 中的 <code>parse</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">User</span>: <span class="title">Decodable</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(data: Data)</span></span> -&gt; <span class="type">User</span>? &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">User</span>(data: data)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">URLSessionClient</span>: <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span>&lt;T: Request&gt;<span class="params">(<span class="number">_</span> r: T, handler: @escaping <span class="params">(T.Response?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        ...</div><div class="line">     <span class="comment">// if let data = data, let res = parse(data: data) &#123;</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> data = data, <span class="keyword">let</span> res = <span class="type">T</span>.<span class="type">Response</span>.parse(data: data) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，将 <code>UserRequest</code> 中不再需要的 <code>host</code> 和 <code>parse</code> 等清理一下，一个类型安全，解耦合的面向协议的网络层就呈现在我们眼前了。想要调用 <code>UserRequest</code> 时，我们可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">URLSessionClient</span>().send(<span class="type">UserRequest</span>(name: <span class="string">"onevcat"</span>)) &#123; user <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> user = user &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(user.message)</span> from <span class="subst">\(user.name)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，你也可以为 <code>URLSessionClient</code> 添加一个单例来减少请求时的创建开销，或者为请求添加 Promise 的调用方式等等。在 POP 的组织下，这些改动都很自然，也不会牵扯到请求的其他部分。你可以用和 <code>UserRequest</code> 类型相似的方式，为网络层添加其他的 API 请求，只需要定义请求所必要的内容，而不用担心会触及网络方面的具体实现。</p>
<h4 id="网络层测试"><a href="#网络层测试" class="headerlink" title="网络层测试"></a>网络层测试</h4><p>将 <code>Client</code> 声明为协议给我们带来了额外的好处，那就是我们不在局限于使用某种特定的技术 (比如这里的 <code>URLSession</code>) 来实现网络请求。利用 POP，你只是定义了一个发送请求的协议，你可以很容易地使用像是 AFNetworking 或者 Alamofire 这样的成熟的第三方框架来构建具体的数据并处理请求的底层实现。我们甚至可以提供一组“虚假”的对请求的响应，用来进行测试。这和传统的 stub &amp; mock 的方式在概念上是接近的，但是实现起来要简单得多，也明确得多。我们现在来看一看具体应该怎么做。</p>
<p>我们先准备一个文本文件，将它添加到项目的测试 target 中，作为网络请求返回的内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 文件名：users:onevcat</span></div><div class="line">&#123;<span class="string">"name"</span>:<span class="string">"Wei Wang"</span>, <span class="string">"message"</span>: <span class="string">"hello"</span>&#125;</div></pre></td></tr></table></figure>
<p>接下来，可以创建一个新的类型，让它满足 <code>Client</code> 协议。但是与 <code>URLSessionClient</code> 不同，这个新类型的 <code>send</code> 方法并不会实际去创建请求，并发送给服务器。我们在测试时需要验证的是一个请求发出后如果服务器按照文档正确响应，那么我们应该也可以得到正确的模型实例。所以这个新的 <code>Client</code> 需要做的事情就是从本地文件中加载定义好的结果，然后验证模型实例是否正确：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LocalFileClient</span>: <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span>&lt;T : Request&gt;<span class="params">(<span class="number">_</span> r: T, handler: @escaping <span class="params">(T.Response?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="keyword">switch</span> r.path &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"/users/onevcat"</span>:</div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> fileURL = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">ProtocolNetworkTests</span>.<span class="keyword">self</span>).url(forResource: <span class="string">"users:onevcat"</span>, withExtension: <span class="string">""</span>) <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">fatalError</span>()</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="type">Data</span>(contentsOf: fileURL) <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">fatalError</span>()</div><div class="line">            &#125;</div><div class="line">            handler(<span class="type">T</span>.<span class="type">Response</span>.parse(data: data))</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="built_in">fatalError</span>(<span class="string">"Unknown path"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 为了满足 `Client` 的要求，实际我们不会发送请求</span></div><div class="line">    <span class="keyword">let</span> host = <span class="string">""</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LocalFileClient</code> 做的事情很简单，它先检查输入请求的 <code>path</code> 属性，如果是 <code>/users/onevcat</code> (也就是我们需要测试的请求)，那么就从测试的 bundle 中读取预先定义的文件，将其作为返回结果进行 <code>parse</code>，然后调用 <code>handler</code>。如果我们需要增加其他请求的测试，可以添加新的 <code>case</code> 项。另外，加载本地文件资源的部分应该使用更通用的写法，不过因为我们这里只是示例，就不过多纠结了。</p>
<p>在 <code>LocalFileClient</code> 的帮助下，现在可以很容易地对 <code>UserRequest</code> 进行测试了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">testUserRequest</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> client = <span class="type">LocalFileClient</span>()</div><div class="line">    client.send(<span class="type">UserRequest</span>(name: <span class="string">"onevcat"</span>)) &#123;</div><div class="line">        user <span class="keyword">in</span></div><div class="line">        <span class="type">XCTAssertNotNil</span>(user)</div><div class="line">        <span class="type">XCTAssertEqual</span>(user!.name, <span class="string">"Wei Wang"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这种方法，我们没有依赖任何第三方测试库，也没有使用 url 代理或者运行时消息转发等等这些复杂的技术，就可以进行请求测试了。保持简单的代码和逻辑，对于项目维护和发展是至关重要的。</p>
<h4 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h4><p>因为高度解耦，这种基于 POP 的实现为代码的扩展提供了相对宽松的可能性。我们刚才已经说过，你不必自行去实现一个完整的 <code>Client</code>，而可以依赖于现有的网络请求框架，实现请求发送的方法即可。也就是说，你也可以很容易地将某个正在使用的请求方式替换为另外的方式，而不会影响到请求的定义和使用。类似地，在 <code>Response</code> 的处理上，现在我们定义了 <code>Decodable</code>，用自己手写的方式在解析模型。我们完全也可以使用任意的第三方 JSON 解析库，来帮助我们迅速构建模型类型，这仅仅只需要实现一个将 <code>Data</code> 转换为对应模型类型的方法即可。</p>
<p>如果你对 POP 方式的网络请求和模型解析感兴趣的话，不妨可以看看 <a href="https://github.com/ishkawa/APIKit" target="_blank" rel="external">APIKit</a> 这个框架，我们在示例中所展示的方法，正是这个框架的核心思想。</p>
<h2 id="合・陪伴-使用协议帮助改善代码设计"><a href="#合・陪伴-使用协议帮助改善代码设计" class="headerlink" title="合・陪伴 - 使用协议帮助改善代码设计"></a>合・陪伴 - 使用协议帮助改善代码设计</h2><p>通过面向协议的编程，我们可以从传统的继承上解放出来，用一种更灵活的方式，搭积木一样对程序进行组装。每个协议专注于自己的功能，特别得益于协议扩展，我们可以减少类和继承带来的共享状态的风险，让代码更加清晰。</p>
<p>高度的协议化有助于解耦、测试以及扩展，而结合泛型来使用协议，更可以让我们免于动态调用和类型转换的苦恼，保证了代码的安全性。</p>
<h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><p>主题演讲后有几位朋友提了一些很有意义的问题，在这里我也稍作整理。有可能问题和回答与当时的情形会有小的出入，仅供参考。</p>
<p><strong>我刚才在看 demo 的时候发现，你都是直接先写 <code>protocol</code>，而不是 <code>struct</code> 或者 <code>class</code>。是不是我们在实践 POP 的时候都应该直接先定义协议？</strong></p>
<blockquote>
<p>我直接写 <code>protocol</code> 是因为我已经对我要做什么有充分的了解，并且希望演讲不要超时。但是实际开发的时候你可能会无法一开始就写出合适的协议定义。建议可以像我在 demo 中做的那样，先“粗略”地进行定义，然后通过不断重构来得到一个最终的版本。当然，你也可以先用纸笔勾勒一个轮廓，然后再去定义和实现协议。当然了，也没人规定一定需要先定义协议，你完全也可以从普通类型开始写起，然后等发现共通点或者遇到我们之前提到的困境时，再回头看看是不是面向协议更加合适，这需要一定的 POP 经验。</p>
</blockquote>
<p><strong>既然 POP 有这么多好处，那我们是不是不再需要面向对象，可以全面转向面向协议了？</strong></p>
<blockquote>
<p>答案可能让你失望。在我们的日常项目中，每天打交道的 Cocoa 其实还是一个带有浓厚 OOP 色彩的框架。也就是说，可能一段时期内我们不可能抛弃 OOP。不过 POP 其实可以和 OOP “和谐共处”，我们也已经看到了不少使用 POP 改善代码设计的例子。另外需要补充的是，POP 其实也并不是银弹，它有不好的一面。最大的问题是协议会增加代码的抽象层级 (这点上和类继承是一样的)，特别是当你的协议又继承了其他协议的时候，这个问题尤为严重。在经过若干层的继承后，满足末端的协议会变得困难，你也难以确定某个方法究竟满足的是哪个协议的要求。这会让代码迅速变得复杂。如果一个协议并没有能描述很多共通点，或者说能让人很快理解的话，可能使用基本的类型还会更简单一些。</p>
</blockquote>
<p><strong>谢谢你的演讲，想问一下你们在项目中使用 POP 的情况</strong></p>
<blockquote>
<p>我们在项目里用了很多 POP 的概念。上面 demo 里的网络请求的例子就是从实际项目中抽出来的，我们觉得这样的请求写起来非常轻松，因为代码很简单，新人进来交接也十分惬意。除了模型层之外，我们在 view 和 view controller 层也用了一些 POP 的代码，比如从 nib 创建 view 的 <code>NibCreatable</code>，支持分页请求 tableview controller 的 <code>NextPageLoadable</code>，空列表时显示页面的 <code>EmptyPage</code> 等等。因为时间有限，不可能展开一一说明，所以这里我只挑选了一个具有代表性，又不是很复杂的网络的例子。其实每个协议都让我们的代码，特别是 View Controller 变短，而且使测试变为可能。可以说，我们的项目从 POP 受益良多，而且我们应该会继续使用下去。</p>
</blockquote>
<h2 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h2><p>几个我认为在 POP 实践中值得一看的资料，愿意再进行深入了解的朋友不妨一看。</p>
<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="external">Protocol-Oriented Programming in Swift</a> - WWDC 15 #408</li>
<li><a href="https://www.youtube.com/watch?v=XWoNjiSPqI8" target="_blank" rel="external">Protocols with Associated Types</a> - @alexisgallagher</li>
<li><a href="http://matthewpalmer.net/blog/2015/08/30/protocol-oriented-programming-in-the-real-world/" target="_blank" rel="external">Protocol Oriented Programming in the Real World</a> - @_matthewpalmer</li>
<li><a href="https://realm.io/news/appbuilders-natasha-muraschev-practical-protocol-oriented-programming/" target="_blank" rel="external">Practical Protocol-Oriented-Programming</a> - @natashatherobot</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是笔者在 MDCC 16 (移动开发者大会) 上 iOS 专场中的主题演讲的文字整理。您可以在&lt;a href=&quot;https://speakerdeck.com/onevcat/mian-xiang-xie-yi-bian-cheng-yu-cocoa-de-xie-ho
    
    </summary>
    
    
      <category term="能工巧匠集" scheme="http://maxmak.tk/tags/%E8%83%BD%E5%B7%A5%E5%B7%A7%E5%8C%A0%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>面向协议编程与 Cocoa 的邂逅 (上)</title>
    <link href="http://maxmak.tk/2016/11/29/2016-11-29-pop-cocoa-1/"/>
    <id>http://maxmak.tk/2016/11/29/2016-11-29-pop-cocoa-1/</id>
    <published>2016-11-28T17:22:11.000Z</published>
    <updated>2017-03-28T10:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是笔者在 MDCC 16 (移动开发者大会) 上 iOS 专场中的主题演讲的文字整理。您可以在<a href="https://speakerdeck.com/onevcat/mian-xiang-xie-yi-bian-cheng-yu-cocoa-de-xie-hou" target="_blank" rel="external">这里</a>找到演讲使用的 Keynote，部分示例代码可以在 MDCC 2016 的<a href="https://github.com/MDCC2016/ProtocolNetwork" target="_blank" rel="external">官方 repo</a> 中找到。因为全部内容比较长，所以分成了上下两个部分，本文 (上) 主要介绍了一些理论方面的内容，包括面向对象编程存在的问题，面向协议的基本概念和决策模型等，<a href="/2016/12/pop-cocoa-2/">下半部分</a>主要展示了一些笔者日常使用面向协议思想和 Cocoa 开发结合的示例代码，并对其进行了一些解说。</p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>面向协议编程 (Protocol Oriented Programming，以下简称 POP) 是 Apple 在 2015 年 WWDC 上提出的 Swift 的一种编程范式。相比与传统的面向对象编程 (OOP)，POP 显得更加灵活。结合 Swift 的值语义特性和 Swift 标准库的实现，这一年来大家发现了很多 POP 的应用场景。本次演讲希望能在介绍 POP 思想的基础上，引入一些日常开发中可以使用 POP 的场景，让与会来宾能够开始在日常工作中尝试 POP，并改善代码设计。</p>
<h2 id="起・初识-什么是-Swift-协议"><a href="#起・初识-什么是-Swift-协议" class="headerlink" title="起・初识 - 什么是 Swift 协议"></a>起・初识 - 什么是 Swift 协议</h2><h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>Swift 标准库中有 50 多个复杂不一的协议，几乎所有的实际类型都是满足若干协议的。protocol 是 Swift 语言的底座，语言的其他部分正是在这个底座上组织和建立起来的。这和我们熟知的面向对象的构建方式很不一样。</p>
<p>一个最简单但是有实际用处的 Swift 协议定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Greetable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这几行代码定义了一个名为 <code>Greetable</code> 的协议，其中有一个 <code>name</code> 属性的定义，以及一个 <code>greet</code> 方法的定义。</p>
<p>所谓协议，就是一组属性和/或方法的定义，而如果某个具体类型想要遵守一个协议，那它需要实现这个协议所定义的所有这些内容。协议实际上做的事情不过是“关于实现的约定”。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>在深入 Swift 协议的概念之前，我想先重新让大家回顾一下面向对象。相信我们不论在教科书或者是博客等各种地方对这个名词都十分熟悉了。那么有一个很有意思，但是其实并不是每个程序员都想过的问题，面向对象的核心思想究竟是什么？</p>
<p>我们先来看一段面向对象的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> leg: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">2</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"eat food."</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"run with <span class="subst">\(leg)</span> legs"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span>: <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">var</span> leg: <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">4</span> &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"eat meat."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> tiger = <span class="type">Tiger</span>()</div><div class="line">tiger.eat() <span class="comment">// "eat meat"</span></div><div class="line">tiger.run() <span class="comment">// "run with 4 legs"</span></div></pre></td></tr></table></figure>
<p>父类 <code>Animal</code> 定义了动物的 <code>leg</code> (这里应该使用虚类，但是 Swift 中没有这个概念，所以先请无视这里的 <code>return 2</code>)，以及动物的 <code>eat</code> 和 <code>run</code> 方法，并为它们提供了实现。子类的 <code>Tiger</code> 根据自身情况重写了 <code>leg</code> (4 条腿)和 <code>eat</code> (吃肉)，而对于 <code>run</code>，父类的实现已经满足需求，因此不必重写。</p>
<p>我们看到 <code>Tiger</code> 和 <code>Animal</code> 共享了一部分代码，这部分代码被封装到了父类中，而除了 <code>Tiger</code> 的其他的子类也能够使用 <code>Animal</code> 的这些代码。这其实就是 OOP 的核心思想 - 使用封装和继承，将一系列相关的内容放到一起。我们的前辈们为了能够对真实世界的对象进行建模，发展出了面向对象编程的概念，但是这套理念有一些缺陷。虽然我们努力用这套抽象和继承的方法进行建模，但是实际的事物往往是一系列<strong>特质的组合</strong>，而不单单是以一脉相承并逐渐扩展的方式构建的。所以最近大家越来越发现面向对象很多时候其实不能很好地对事物进行抽象，我们可能需要寻找另一种更好的方式。</p>
<h3 id="面向对象编程的困境"><a href="#面向对象编程的困境" class="headerlink" title="面向对象编程的困境"></a>面向对象编程的困境</h3><h4 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h4><p>我们再来看一个例子。这次让我们远离动物世界，回到 Cocoa，假设我们有一个 <code>ViewController</code>，它继承自 <code>UIViewController</code>，我们向其中添加一个 <code>myMethod</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewCotroller</span>: <span class="title">UIViewController</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 继承</span></div><div class="line">    <span class="comment">// view, isFirstResponder()...</span></div><div class="line">    </div><div class="line">    <span class="comment">// 新加</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这时候我们又有一个继承自 <code>UITableViewController</code> 的 <code>AnotherViewController</code>，我们也想向其中添加同样的 <code>myMethod</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherViewController</span>: <span class="title">UITableViewController</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 继承</span></div><div class="line">    <span class="comment">// tableView, isFirstResponder()...</span></div><div class="line">    </div><div class="line">    <span class="comment">// 新加</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时，我们迎来了 OOP 的第一个大困境，那就是我们很难在不同继承关系的类里共用代码。这里的问题用“行话”来说叫做“横切关注点” (Cross-Cutting Concerns)。我们的关注点 <code>myMethod</code> 位于两条继承链 (<code>UIViewController</code> -&gt; <code>ViewCotroller</code> 和 <code>UIViewController</code> -&gt; <code>UITableViewController</code> -&gt; <code>AnotherViewController</code>) 的横切面上。面向对象是一种不错的抽象方式，但是肯定不是最好的方式。它无法描述两个不同事物具有某个相同特性这一点。在这里，特性的组合要比继承更贴切事物的本质。</p>
<p>想要解决这个问题，我们有几个方案：</p>
<ul>
<li><p>Copy &amp; Paste</p>
<p>  这是一个比较糟糕的解决方案，但是演讲现场还是有不少朋友选择了这个方案，特别是在工期很紧，无暇优化的情况下。这诚然可以理解，但是这也是坏代码的开头。我们应该尽量避免这种做法。</p>
</li>
<li><p>引入 BaseViewController</p>
<p>在一个继承自 <code>UIViewController</code> 的 <code>BaseViewController</code> 上添加需要共享的代码，或者干脆在 <code>UIViewController</code> 上添加 extension。看起来这是一个稍微靠谱的做法，但是如果不断这么做，会让所谓的 <code>Base</code> 很快变成垃圾堆。职责不明确，任何东西都能扔进 <code>Base</code>，你完全不知道哪些类走了 <code>Base</code>，而这个“超级类”对代码的影响也会不可预估。</p>
</li>
<li><p>依赖注入</p>
<p>通过外界传入一个带有 <code>myMethod</code> 的对象，用新的类型来提供这个功能。这是一个稍好的方式，但是引入额外的依赖关系，可能也是我们不太愿意看到的。</p>
</li>
<li><p>多继承</p>
<p>当然，Swift 是不支持多继承的。不过如果有多继承的话，我们确实可以从多个父类进行继承，并将 <code>myMethod</code> 添加到合适的地方。有一些语言选择了支持多继承 (比如 C++)，但是它会带来 OOP 中另一个著名的问题：菱形缺陷。</p>
</li>
</ul>
<h4 id="菱形缺陷"><a href="#菱形缺陷" class="headerlink" title="菱形缺陷"></a>菱形缺陷</h4><p>上面的例子中，如果我们有多继承，那么 <code>ViewController</code> 和 <code>AnotherViewController</code> 的关系可能会是这样的：</p>
<p><img src="/assets/images/2016/diamond.png" alt=""></p>
<p>在上面这种拓扑结构中，我们只需要在 <code>ViewController</code> 中实现 <code>myMethod</code>，在 <code>AnotherViewController</code> 中也就可以继承并使用它了。看起来很完美，我们避免了重复。但是多继承有一个无法回避的问题，就是两个父类都实现了同样的方法时，子类该怎么办？我们很难确定应该继承哪一个父类的方法。因为多继承的拓扑结构是一个菱形，所以这个问题又被叫做菱形缺陷 (Diamond Problem)。像是 C++ 这样的语言选择粗暴地将菱形缺陷的问题交给程序员处理，这无疑非常复杂，并且增加了人为错误的可能性。而绝大多数现代语言对多继承这个特性选择避而远之。</p>
<h4 id="动态派发安全性"><a href="#动态派发安全性" class="headerlink" title="动态派发安全性"></a>动态派发安全性</h4><p>Objective-C 恰如其名，是一门典型的 OOP 语言，同时它继承了 Small Talk 的消息发送机制。这套机制十分灵活，是 OC 的基础思想，但是有时候相对危险。考虑下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ViewController *v1 = ...</div><div class="line">[v1 myMethod];</div><div class="line"></div><div class="line">AnotherViewController *v2 = ...</div><div class="line">[v2 myMethod];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *array = @[v1, v2];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> array) &#123;</div><div class="line">    [obj myMethod];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们如果在 <code>ViewController</code> 和 <code>AnotherViewController</code> 中都实现了 <code>myMethod</code> 的话，这段代码是没有问题的。<code>myMethod</code> 将会被动态发送给 <code>array</code> 中的 <code>v1</code> 和 <code>v2</code>。但是，要是我们有一个没有实现 <code>myMethod</code> 的类型，会如何呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> *v3 = [<span class="built_in">NSObject</span> new]</div><div class="line"><span class="comment">// v3 没有实现 `myMethod`</span></div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *array = @[v1, v2, v3];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> array) &#123;</div><div class="line">    [obj myMethod];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Runtime error:</span></div><div class="line"><span class="comment">// unrecognized selector sent to instance blabla</span></div></pre></td></tr></table></figure>
<p>编译依然可以通过，但是显然，程序将在运行时崩溃。Objective-C 是不安全的，编译器默认你知道某个方法确实有实现，这是消息发送的灵活性所必须付出的代价。而在 app 开发看来，用可能的崩溃来换取灵活性，显然这个代价太大了。虽然这不是 OOP 范式的问题，但它确实在 Objective-C 时代给我们带来了切肤之痛。</p>
<h4 id="三大困境"><a href="#三大困境" class="headerlink" title="三大困境"></a>三大困境</h4><p>我们可以总结一下 OOP 面临的这几个问题。</p>
<ul>
<li>动态派发安全性</li>
<li>横切关注点</li>
<li>菱形缺陷</li>
</ul>
<p>首先，在 OC 中动态派发让我们承担了在运行时才发现错误的风险，这很有可能是发生在上线产品中的错误。其次，横切关注点让我们难以对对象进行完美的建模，代码的重用也会更加糟糕。</p>
<h2 id="承・相知-协议扩展和面向协议编程"><a href="#承・相知-协议扩展和面向协议编程" class="headerlink" title="承・相知 - 协议扩展和面向协议编程"></a>承・相知 - 协议扩展和面向协议编程</h2><h3 id="使用协议解决-OOP-困境"><a href="#使用协议解决-OOP-困境" class="headerlink" title="使用协议解决 OOP 困境"></a>使用协议解决 OOP 困境</h3><p>协议并不是什么新东西，也不是 Swift 的发明。在 Java 和 C# 里，它叫做 <code>Interface</code>。而 Swift 中的 protocol 将这个概念继承了下来，并发扬光大。让我们回到一开始定义的那个简单协议，并尝试着实现这个协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Greetable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Greetable</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"你好 <span class="subst">\(name)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="type">Person</span>(name: <span class="string">"Wei Wang"</span>).greet()</div></pre></td></tr></table></figure>
<p>实现很简单，<code>Person</code> 结构体通过实现 <code>name</code> 和 <code>greet</code> 来满足 <code>Greetable</code>。在调用时，我们就可以使用 <code>Greetable</code> 中定义的方法了。</p>
<h4 id="动态派发安全性-1"><a href="#动态派发安全性-1" class="headerlink" title="动态派发安全性"></a>动态派发安全性</h4><p>除了 <code>Person</code>，其他类型也可以实现 <code>Greetable</code>，比如 <code>Cat</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span>: <span class="title">Greetable</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"meow~ <span class="subst">\(name)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我们就可以将协议作为标准类型，来对方法调用进行动态派发了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> array: [<span class="type">Greetable</span>] = [</div><div class="line">		<span class="type">Person</span>(name: <span class="string">"Wei Wang"</span>), </div><div class="line">		<span class="type">Cat</span>(name: <span class="string">"onevcat"</span>)]</div><div class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> array &#123;</div><div class="line">	obj.greet()</div><div class="line">&#125;</div><div class="line"><span class="comment">// 你好 Wei Wang</span></div><div class="line"><span class="comment">// meow~ onevcat</span></div></pre></td></tr></table></figure>
<p>对于没有实现 Greetbale 的类型，编译器将返回错误，因此不存在消息误发送的情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bug</span>: <span class="title">Greetable</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Compiler Error: </span></div><div class="line"><span class="comment">// 'Bug' does not conform to protocol 'Greetable'</span></div><div class="line"><span class="comment">// protocol requires function 'greet()'</span></div></pre></td></tr></table></figure>
<p>这样一来，动态派发安全性的问题迎刃而解。如果你保持在 Swift 的世界里，那这个你的所有代码都是安全的。</p>
<ul>
<li>✅ 动态派发安全性</li>
<li>横切关注点</li>
<li>菱形缺陷</li>
</ul>
<h4 id="横切关注点-1"><a href="#横切关注点-1" class="headerlink" title="横切关注点"></a>横切关注点</h4><p>使用协议和协议扩展，我们可以很好地共享代码。回到上一节的 <code>myMethod</code> 方法，我们来看看如何使用协议来搞定它。首先，我们可以定义一个含有 <code>myMethod</code> 的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这个协议没有提供任何的实现。我们依然需要在实际类型遵守这个协议的时候为它提供具体的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// class ViewController: UIViewController</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">P</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        doWork()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// class AnotherViewController: UITableViewController</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AnotherViewController</span>: <span class="title">P</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        doWork()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能不禁要问，这和 Copy &amp; Paste 的解决方式有何不同？没错，答案就是 – 没有不同。不过稍安勿躁，我们还有其他科技可以解决这个问题，那就是协议扩展。协议本身并不是很强大，只是静态类型语言的编译器保证，在很多静态语言中也有类似的概念。那到底是什么让 Swift 成为了一门协议优先的语言？真正使协议发生质变，并让大家如此关注的原因，其实是在 WWDC 2015 和 Swift 2 发布时，Apple 为协议引入了一个新特性，协议扩展，它为 Swift 语言带来了一次革命性的变化。</p>
<p>所谓协议扩展，就是我们可以为一个协议提供默认的实现。对于 <code>P</code>，可以在 <code>extension P</code> 中为 <code>myMethod</code> 添加一个实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">P</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">()</span></span> &#123;</div><div class="line">        doWork()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了这个协议扩展后，我们只需要简单地声明 <code>ViewController</code> 和 <code>AnotherViewController</code> 遵守 <code>P</code>，就可以直接使用 <code>myMethod</code> 的实现了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">P</span> </span>&#123; &#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AnotherViewController</span>: <span class="title">P</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">viewController.myMethod()</div><div class="line">anotherViewController.myMethod()</div></pre></td></tr></table></figure>
<p>不仅如此，除了已经定义过的方法，我们甚至可以在扩展中添加协议里没有定义过的方法。在这些额外的方法中，我们可以依赖协议定义过的方法进行操作。我们之后会看到更多的例子。总结下来：</p>
<ul>
<li>协议定义<ul>
<li>提供实现的入口</li>
<li>遵循协议的类型需要对其进行实现</li>
</ul>
</li>
<li>协议扩展<ul>
<li>为入口提供默认实现</li>
<li>根据入口提供额外实现</li>
</ul>
</li>
</ul>
<p>这样一来，横切点关注的问题也简单安全地得到了解决。</p>
<ul>
<li>✅ 动态派发安全性</li>
<li>✅ 横切关注点</li>
<li>菱形缺陷</li>
</ul>
<h4 id="菱形缺陷-1"><a href="#菱形缺陷-1" class="headerlink" title="菱形缺陷"></a>菱形缺陷</h4><p>最后我们看看多继承。多继承中存在的一个重要问题是菱形缺陷，也就是子类无法确定使用哪个父类的方法。在协议的对应方面，这个问题虽然依然存在，但却是可以唯一安全地确定的。我们来看一个多个协议中出现同名元素的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Nameable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Identifiable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">var</span> id: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有一个类型，需要同时实现两个协议的话，它<strong>必须</strong>提供一个 <code>name</code> 属性，来<strong>同时</strong>满足两个协议的要求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Nameable</span>, <span class="title">Identifiable</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span> </div><div class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// `name` 属性同时满足 Nameable 和 Identifiable 的 name</span></div></pre></td></tr></table></figure>
<p>这里比较有意思，又有点让人困惑的是，如果我们为其中的某个协议进行了扩展，在其中提供了默认的 <code>name</code> 实现，会如何。考虑下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Nameable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"default name"</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Nameable</span>, <span class="title">Identifiable</span> </span>&#123;</div><div class="line">    <span class="comment">// let name: String </span></div><div class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Identifiable 也将使用 Nameable extension 中的 name</span></div></pre></td></tr></table></figure>
<p>这样的编译是可以通过的，虽然 <code>Person</code> 中没有定义 <code>name</code>，但是通过 <code>Nameable</code> 的 <code>name</code> (因为它是静态派发的)，<code>Person</code> 依然可以遵守 <code>Identifiable</code>。不过，当 <code>Nameable</code> 和 <code>Identifiable</code> 都有 <code>name</code> 的协议扩展的话，就无法编译了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Nameable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"default name"</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Identifiable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"another default name"</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Nameable</span>, <span class="title">Identifiable</span> </span>&#123;</div><div class="line">    <span class="comment">// let name: String </span></div><div class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 无法编译，name 属性冲突</span></div></pre></td></tr></table></figure>
<p>这种情况下，<code>Person</code> 无法确定要使用哪个协议扩展中 <code>name</code> 的定义。在同时实现两个含有同名元素的协议，<strong>并且</strong>它们都提供了默认扩展时，我们需要在具体的类型中明确地提供实现。这里我们将 <code>Person</code> 中的 <code>name</code> 进行实现就可以了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Nameable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"default name"</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Identifiable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"another default name"</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Nameable</span>, <span class="title">Identifiable</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span> </div><div class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">Person</span>(name: <span class="string">"onevcat"</span>, id: <span class="number">123</span>).name <span class="comment">// onevcat</span></div></pre></td></tr></table></figure>
<p>这里的行为看起来和菱形问题很像，但是有一些本质不同。首先，这个问题出现的前提条件是同名元素<strong>以及</strong>同时提供了实现，而协议扩展对于协议本身来说并不是必须的。其次，我们在具体类型中提供的实现一定是安全和确定的。当然，菱形缺陷没有被完全解决，Swift 还不能很好地处理多个协议的冲突，这是 Swift 现在的不足。</p>
<ul>
<li>✅ 动态派发安全性</li>
<li>✅ 横切关注点</li>
<li>❓菱形缺陷</li>
</ul>
<p><a href="/2016/12/pop-cocoa-2/">本文的下半部分</a>将展示一些笔者日常使用面向协议思想和 Cocoa 开发结合的示例代码，并对其进行了一些解说。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是笔者在 MDCC 16 (移动开发者大会) 上 iOS 专场中的主题演讲的文字整理。您可以在&lt;a href=&quot;https://speakerdeck.com/onevcat/mian-xiang-xie-yi-bian-cheng-yu-cocoa-de-xie-ho
    
    </summary>
    
    
      <category term="能工巧匠集" scheme="http://maxmak.tk/tags/%E8%83%BD%E5%B7%A5%E5%B7%A7%E5%8C%A0%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>活久见的重构 - iOS 10 UserNotifications 框架解析</title>
    <link href="http://maxmak.tk/2016/08/08/2016-08-08-notification/"/>
    <id>http://maxmak.tk/2016/08/08/2016-08-08-notification/</id>
    <published>2016-08-07T17:22:11.000Z</published>
    <updated>2017-03-28T10:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>iOS 10 中以前杂乱的和通知相关的 API 都被统一了，现在开发者可以使用独立的 UserNotifications.framework 来集中管理和使用 iOS 系统中通知的功能。在此基础上，Apple 还增加了撤回单条通知，更新已展示通知，中途修改通知内容，在通知中展示图片视频，自定义通知 UI 等一系列新功能，非常强大。</p>
<p>对于开发者来说，相较于之前版本，iOS 10 提供了一套非常易用的通知处理接口，是 SDK 的一次重大重构。而之前的绝大部分通知相关 API 都已经被标为弃用 (deprecated)。</p>
<p>这篇文章将首先回顾一下 Notification 的发展历史和现状，然后通过一些例子来展示 iOS 10 SDK 中相应的使用方式，来说明新 SDK 中通知可以做的事情以及它们的使用方式。</p>
<p>您可以在 WWDC 16 的 <a href="https://developer.apple.com/videos/play/wwdc2016/707/" target="_blank" rel="external">Introduction to Notifications</a> 和 <a href="https://developer.apple.com/videos/play/wwdc2016/708/" target="_blank" rel="external">Advanced Notifications</a> 这两个 Session 中找到详细信息；另外也不要忘了参照 <a href="https://developer.apple.com/reference/usernotifications" target="_blank" rel="external">UserNotifications 的官方文档</a>以及本文的<a href="https://github.com/onevcat/UserNotificationDemo" target="_blank" rel="external">实例项目 UserNotificationDemo</a>。</p>
<h2 id="Notification-历史和现状"><a href="#Notification-历史和现状" class="headerlink" title="Notification 历史和现状"></a>Notification 历史和现状</h2><p>碎片化时间是移动设备用户在使用应用时的一大特点，用户希望随时拿起手机就能查看资讯，处理事务，而通知可以在重要的事件和信息发生时提醒用户。完美的通知展示可以很好地帮助用户使用应用，体现出应用的价值，进而有很大可能将用户带回应用，提高活跃度。正因如此，不论是 Apple 还是第三方开发者们，都很重视通知相关的开发工作，而通知也成为了很多应用的必备功能，开发者们都希望通知能带来更好地体验和更多的用户。</p>
<p>但是理想的丰满并不能弥补现实的骨感。自从在 iOS 3 引入 Push Notification 后，之后几乎每个版本 Apple 都在加强这方面的功能。我们可以回顾一下整个历程和相关的主要 API：</p>
<ul>
<li>iOS 3 - 引入推送通知<br>  <code>UIApplication</code> 的 <code>registerForRemoteNotificationTypes</code> 与 <code>UIApplicationDelegate</code> 的 <code>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</code>，<code>application(_:didReceiveRemoteNotification:)</code></li>
<li>iOS 4 - 引入本地通知<br>  <code>scheduleLocalNotification</code>，<code>presentLocalNotificationNow:</code>，<code>application(_:didReceive:)</code></li>
<li>iOS 5 - 加入通知中心页面</li>
<li>iOS 6 - 通知中心页面与 iCloud 同步</li>
<li>iOS 7 - 后台静默推送<br>  <code>application(_:didReceiveRemoteNotification:fetchCompletionHandle:)</code></li>
<li>iOS 8 - 重新设计 notification 权限请求，Actionable 通知<br>  <code>registerUserNotificationSettings(_:)</code>，<code>UIUserNotificationAction</code> 与 <code>UIUserNotificationCategory</code>，<code>application(_:handleActionWithIdentifier:forRemoteNotification:completionHandler:)</code> 等</li>
<li>iOS 9 - Text Input action，基于 HTTP/2 的推送请求<br>  <code>UIUserNotificationActionBehavior</code>，全新的 Provider API 等</li>
</ul>
<p>有点晕，不是么？一个开发者很难在不借助于文档的帮助下区分 <code>application(_:didReceiveRemoteNotification:)</code> 和 <code>application(_:didReceiveRemoteNotification:fetchCompletionHandle:)</code>，新入行的开发者也不可能明白 <code>registerForRemoteNotificationTypes</code> 和 <code>registerUserNotificationSettings(_:)</code> 之间是不是有什么关系，Remote 和 Local Notification 除了在初始化方式之外那些细微的区别也让人抓狂，而很多 API 都被随意地放在了 <code>UIApplication</code> 或者 <code>UIApplicationDelegate</code> 中。除此之外，应用已经在前台时，远程推送是无法直接显示的，要先捕获到远程来的通知，然后再发起一个本地通知才能完成显示。更让人郁闷的是，应用在运行时和非运行时捕获通知的路径还不一致。虽然这些种种问题都是由一定历史原因造成的，但不可否认，正是混乱的组织方式和之前版本的考虑不周，使得 iOS 通知方面的开发一直称不上“让人愉悦”，甚至有不少“坏代码”的味道。</p>
<p>另一方面，现在的通知功能相对还是简单，我们能做的只是本地或者远程发起通知，然后显示给用户。虽然 iOS 8 和 9 中添加了按钮和文本来进行交互，但是已发出的通知不能更新，通知的内容也只是在发起时唯一确定，而这些内容也只能是简单的文本。 想要在现有基础上扩展通知的功能，势必会让原本就盘根错节的 API 更加难以理解。</p>
<p>在 iOS 10 中新加入 UserNotifications 框架，可以说是 iOS SDK 发展到现在的最大规模的一次重构。新版本里通知的相关功能被提取到了单独的框架，通知也不再区分类型，而有了更统一的行为。我们接下来就将由浅入深地解析这个重构后的框架的使用方式。</p>
<h2 id="UserNotifications-框架解析"><a href="#UserNotifications-框架解析" class="headerlink" title="UserNotifications 框架解析"></a>UserNotifications 框架解析</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>iOS 10 中通知相关的操作遵循下面的流程：</p>
<p><img src="/assets/images/2016/notification-flow.png" alt=""></p>
<p>首先你需要向用户请求推送权限，然后发送通知。对于发送出的通知，如果你的应用位于后台或者没有运行的话，系统将通过用户允许的方式 (弹窗，横幅，或者是在通知中心) 进行显示。如果你的应用已经位于前台正在运行，你可以自行决定要不要显示这个通知。最后，如果你希望用户点击通知能有打开应用以外的额外功能的话，你也需要进行处理。</p>
<h3 id="权限申请"><a href="#权限申请" class="headerlink" title="权限申请"></a>权限申请</h3><h4 id="通用权限"><a href="#通用权限" class="headerlink" title="通用权限"></a>通用权限</h4><p>iOS 8 之前，本地推送 (<code>UILocalNotification</code>) 和远程推送 (Remote Notification) 是区分对待的，应用只需要在进行远程推送时获取用户同意。iOS 8 对这一行为进行了规范，因为无论是本地推送还是远程推送，其实在用户看来表现是一致的，都是打断用户的行为。因此从 iOS 8 开始，这两种通知都需要申请权限。iOS 10 里进一步消除了本地通知和推送通知的区别。向用户申请通知权限非常简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">UNUserNotificationCenter</span>.current().requestAuthorization(options: [.alert, .sound, .badge]) &#123;</div><div class="line">    granted, error <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> granted &#123;</div><div class="line">        <span class="comment">// 用户允许进行通知</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，在使用 UN 开头的 API 的时候，不要忘记导入 UserNotifications 框架：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UserNotifications</div></pre></td></tr></table></figure>
<p>第一次调用这个方法时，会弹出一个系统弹窗。</p>
<p><img src="/assets/images/2016/notification-auth-alert.png" alt=""></p>
<p>要注意的是，一旦用户拒绝了这个请求，再次调用该方法也不会再进行弹窗，想要应用有机会接收到通知的话，用户必须自行前往系统的设置中为你的应用打开通知，如果不是杀手级应用，想让用户主动去在茫茫多 app 中找到你的那个并专门为你开启通知，往往是不可能的。因此，在合适的时候弹出请求窗，在请求权限前预先进行说明，以此增加通过的概率应该是开发者和策划人员的必修课。相比与直接简单粗暴地在启动的时候就进行弹窗，耐心诱导会是更明智的选择。</p>
<h4 id="远程推送"><a href="#远程推送" class="headerlink" title="远程推送"></a>远程推送</h4><p>一旦用户同意后，你就可以在应用中发送本地通知了。不过如果你通过服务器发送远程通知的话，还需要多一个获取用户 token 的操作。你的服务器可以使用这个 token 将用向 Apple Push Notification 的服务器提交请求，然后 APNs 通过 token 识别设备和应用，将通知推给用户。</p>
<p>提交 token 请求和获得 token 的回调是现在“唯二”不在新框架中的 API。我们使用 <code>UIApplication</code> 的 <code>registerForRemoteNotifications</code> 来注册远程通知，在 <code>AppDelegate</code> 的 <code>application(_:didRegisterForRemoteNotificationsWithDeviceToken)</code> 中获取用户 token：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 向 APNs 请求 token：</span></div><div class="line"><span class="type">UIApplication</span>.shared.registerForRemoteNotifications()</div><div class="line"></div><div class="line"><span class="comment">// AppDelegate.swift</span></div><div class="line"> <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> tokenString = deviceToken.hexString</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Get Push token: <span class="subst">\(tokenString)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取得到的 <code>deviceToken</code> 是一个 <code>Data</code> 类型，为了方便使用和传递，我们一般会选择将它转换为一个字符串。Swift 3 中可以使用下面的 <code>Data</code> 扩展来构造出适合传递给 Apple 的字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Data</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> hexString: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> withUnsafeBytes &#123;(bytes: <span class="type">UnsafePointer</span>&lt;<span class="type">UInt8</span>&gt;) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">            <span class="keyword">let</span> buffer = <span class="type">UnsafeBufferPointer</span>(start: bytes, <span class="built_in">count</span>: <span class="built_in">count</span>)</div><div class="line">            <span class="keyword">return</span> buffer.<span class="built_in">map</span> &#123;<span class="type">String</span>(format: <span class="string">"%02hhx"</span>, $<span class="number">0</span>)&#125;.<span class="built_in">reduce</span>(<span class="string">""</span>, &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h4><p>用户可以在系统设置中修改你的应用的通知权限，除了打开和关闭全部通知权限外，用户也可以限制你的应用只能进行某种形式的通知显示，比如只允许横幅而不允许弹窗及通知中心显示等。一般来说你不应该对用户的选择进行干涉，但是如果你的应用确实需要某种特定场景的推送的话，你可以对当前用户进行的设置进行检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">UNUserNotificationCenter.current().getNotificationSettings &#123;</div><div class="line">    settings in </div><div class="line">    print(settings.authorizationStatus) // .authorized | .denied | .notDetermined</div><div class="line">    print(settings.badgeSetting) // .enabled | .disabled | .notSupported</div><div class="line">    // etc...</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">&gt; 关于权限方面的使用，可以参考 Demo 中 [`AuthorizationViewController`](https://github.com/onevcat/UserNotificationDemo/blob/master/UserNotificationDemo/AuthorizationViewController.swift) 的内容。</div><div class="line"></div><div class="line">### 发送通知</div><div class="line"></div><div class="line">UserNotifications 中对通知进行了统一。我们通过通知的内容 (`UNNotificationContent`)，发送的时机 (`UNNotificationTrigger`) 以及一个发送通知的 `String` 类型的标识符，来生成一个 `UNNotificationRequest`  类型的发送请求。最后，我们将这个请求添加到 `UNUserNotificationCenter.current()` 中，就可以等待通知到达了：</div><div class="line"></div><div class="line">```swift</div><div class="line">// 1. 创建通知内容</div><div class="line">let content = UNMutableNotificationContent()</div><div class="line">content.title = &quot;Time Interval Notification&quot;</div><div class="line">content.body = &quot;My first notification&quot;</div><div class="line"></div><div class="line">// 2. 创建发送触发</div><div class="line">let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)</div><div class="line"></div><div class="line">// 3. 发送请求标识符</div><div class="line">let requestIdentifier = &quot;com.onevcat.usernotification.myFirstNotification&quot;</div><div class="line"></div><div class="line">// 4. 创建一个发送请求</div><div class="line">let request = UNNotificationRequest(identifier: requestIdentifier, content: content, trigger: trigger)</div><div class="line"></div><div class="line">// 将请求添加到发送中心</div><div class="line">UNUserNotificationCenter.current().add(request) &#123; error in</div><div class="line">    if error == nil &#123;</div><div class="line">        print(&quot;Time Interval Notification scheduled: \(requestIdentifier)&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>iOS 10 中通知不仅支持简单的一行文字，你还可以添加 <code>title</code> 和 <code>subtitle</code>，来用粗体字的形式强调通知的目的。对于远程推送，iOS 10 之前一般只含有消息的推送 payload 是这样的：</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"aps"</span>:&#123;</div><div class="line">    <span class="attr">"alert"</span>:<span class="string">"Test"</span>,</div><div class="line">    <span class="attr">"sound"</span>:<span class="string">"default"</span>,</div><div class="line">    <span class="attr">"badge"</span>:<span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 如果我们想要加入 <code>title</code> 和 <code>subtitle</code> 的话，则需要将 <code>alert</code> 从字符串换为字典，新的 payload 是：</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"aps"</span>:&#123;</div><div class="line">    <span class="attr">"alert"</span>:&#123;</div><div class="line">      <span class="attr">"title"</span>:<span class="string">"I am title"</span>,</div><div class="line">      <span class="attr">"subtitle"</span>:<span class="string">"I am subtitle"</span>,</div><div class="line">      <span class="attr">"body"</span>:<span class="string">"I am body"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"sound"</span>:<span class="string">"default"</span>,</div><div class="line">    <span class="attr">"badge"</span>:<span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>好消息是，后一种字典的方法其实在 iOS 8.2 的时候就已经存在了。虽然当时 `title` 只是用在 Apple Watch 上的，但是设置好 `body` 的话在 iOS 上还是可以显示的，所以针对 iOS 10 添加标题时是可以保证前向兼容的。

另外，如果要进行本地化对应，在设置这些内容文本时，本地可以使用 `String.localizedUserNotificationString(forKey: &quot;your_key&quot;, arguments: [])` 的方式来从 Localizable.strings 文件中取出本地化字符串，而远程推送的话，也可以在 payload 的 alert 中使用 `loc-key` 或者 `title-loc-key` 来进行指定。关于 payload 中的 key，可以参考[这篇文档](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/PayloadKeyReference.html)。
</code></pre><ol>
<li>触发器是只对本地通知而言的，远程推送的通知的话默认会在收到后立即显示。现在 UserNotifications 框架中提供了三种触发器，分别是：在一定时间后触发 <code>UNTimeIntervalNotificationTrigger</code>，在某月某日某时触发 <code>UNCalendarNotificationTrigger</code> 以及在用户进入或是离开某个区域时触发 <code>UNLocationNotificationTrigger</code>。</li>
<li>请求标识符可以用来区分不同的通知请求，在将一个通知请求提交后，通过特定 API 我们能够使用这个标识符来取消或者更新这个通知。我们将在稍后再提到具体用法。</li>
<li>在新版本的通知框架中，Apple 借用了一部分网络请求的概念。我们组织并发送一个通知请求，然后将这个请求提交给 <code>UNUserNotificationCenter</code> 进行处理。我们会在 delegate 中接收到这个通知请求对应的 response，另外我们也有机会在应用的 extension 中对 request 进行处理。我们在接下来的章节会看到更多这方面的内容。</li>
</ol>
<p>在提交通知请求后，我们锁屏或者将应用切到后台，并等待设定的时间后，就能看到我们的通知出现在通知中心或者屏幕横幅了：</p>
<p><img src="/assets/images/2016/notification-alert.png" alt=""></p>
<blockquote>
<p>关于最基础的通知发送，可以参考 Demo 中 <a href="https://github.com/onevcat/UserNotificationDemo/blob/master/UserNotificationDemo/TimeIntervalViewController.swift" target="_blank" rel="external"><code>TimeIntervalViewController</code></a> 的内容。</p>
</blockquote>
<h3 id="取消和更新"><a href="#取消和更新" class="headerlink" title="取消和更新"></a>取消和更新</h3><p>在创建通知请求时，我们已经指定了标识符。这个标识符可以用来管理通知。在 iOS 10 之前，我们很难取消掉某一个特定的通知，也不能主动移除或者更新已经展示的通知。想象一下你需要推送用户账户内的余额变化情况，多次的余额增减或者变化很容易让用户十分困惑 - 到底哪条通知才是最正确的？又或者在推送一场比赛的比分时，频繁的通知必然导致用户通知中心数量爆炸，而大部分中途的比分对于用户来说只是噪音。</p>
<p>iOS 10 中，UserNotifications 框架提供了一系列管理通知的 API，你可以做到：</p>
<ul>
<li>取消还未展示的通知</li>
<li>更新还未展示的通知</li>
<li>移除已经展示过的通知</li>
<li>更新已经展示过的通知</li>
</ul>
<p>其中关键就在于在创建请求时使用同样的标识符。</p>
<p>比如，从通知中心中移除一个展示过的通知：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> trigger = <span class="type">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class="number">3</span>, repeats: <span class="literal">false</span>)</div><div class="line"><span class="keyword">let</span> identifier = <span class="string">"com.onevcat.usernotification.notificationWillBeRemovedAfterDisplayed"</span></div><div class="line"><span class="keyword">let</span> request = <span class="type">UNNotificationRequest</span>(identifier: identifier, content: content, trigger: trigger)</div><div class="line"></div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().add(request) &#123; error <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Notification request added: <span class="subst">\(identifier)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">delay(<span class="number">4</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Notification request removed: <span class="subst">\(identifier)</span>"</span>)</div><div class="line">    <span class="type">UNUserNotificationCenter</span>.current().removeDeliveredNotifications(withIdentifiers: [identifier])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类似地，我们可以使用 <code>removePendingNotificationRequests</code>，来取消还未展示的通知请求。对于更新通知，不论是否已经展示，都和一开始添加请求时一样，再次将请求提交给 <code>UNUserNotificationCenter</code> 即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// let request: UNNotificationRequest = ...</span></div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().add(request) &#123; error <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Notification request added: <span class="subst">\(identifier)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">delay(<span class="number">2</span>) &#123;</div><div class="line">    <span class="keyword">let</span> newTrigger = <span class="type">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class="number">1</span>, repeats: <span class="literal">false</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// Add new request with the same identifier to update a notification.</span></div><div class="line">    <span class="keyword">let</span> newRequest = <span class="type">UNNotificationRequest</span>(identifier: identifier, content:newContent, trigger: newTrigger)</div><div class="line">    <span class="type">UNUserNotificationCenter</span>.current().add(newRequest) &#123; error <span class="keyword">in</span></div><div class="line">        <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Notification request updated: <span class="subst">\(identifier)</span>"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>远程推送可以进行通知的更新，在使用 Provider API 向 APNs 提交请求时，在 HTTP/2 的 header 中 <code>apns-collapse-id</code> key 的内容将被作为该推送的标识符进行使用。多次推送同一标识符的通知即可进行更新。</p>
<blockquote>
<p>对应本地的 <code>removeDeliveredNotifications</code>，现在还不能通过类似的方式，向 APNs 发送一个包含 collapse id 的 DELETE 请求来删除已经展示的推送，APNs 服务器并不接受一个 DELETE 请求。不过从技术上来说 Apple 方面应该不存在什么问题，我们可以拭目以待。现在如果想要消除一个远程推送，可以选择使用后台静默推送的方式来从本地发起一个删除通知的调用。关于后台推送的部分，可以参考我之前的一篇关于 <a href="https://onevcat.com/2013/08/ios7-background-multitask/" target="_blank" rel="external">iOS7 中的多任务</a>的文章。</p>
<p>关于通知管理，可以参考 Demo 中 <a href="https://github.com/onevcat/UserNotificationDemo/blob/master/UserNotificationDemo/ManagementViewController.swift" target="_blank" rel="external"><code>ManagementViewController</code></a> 的内容。为了能够简单地测试远程推送，一般我们都会用一些方便发送通知的工具，<a href="https://github.com/KnuffApp/Knuff" target="_blank" rel="external">Knuff</a> 就是其中之一。我也为 Knuff 添加了 <code>apns-collapse-id</code> 的支持，你可以在这个 <a href="https://github.com/onevcat/Knuff" target="_blank" rel="external">fork 的 repo</a> 或者是原 repo 的 <a href="https://github.com/KnuffApp/Knuff/pull/52" target="_blank" rel="external">pull request</a> 中找到相关信息。</p>
</blockquote>
<h3 id="处理通知"><a href="#处理通知" class="headerlink" title="处理通知"></a>处理通知</h3><h4 id="应用内展示通知"><a href="#应用内展示通知" class="headerlink" title="应用内展示通知"></a>应用内展示通知</h4><p>现在系统可以在应用处于后台或者退出的时候向用户展示通知了。不过，当应用处于前台时，收到的通知是无法进行展示的。如果我们希望在应用内也能显示通知的话，需要额外的工作。</p>
<p><code>UNUserNotificationCenterDelegate</code> 提供了两个方法，分别对应如何在应用内展示通知，和收到通知响应时要如何处理的工作。我们可以实现这个接口中的对应方法来在应用内展示通知：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationHandler</span>: <span class="title">NSObject</span>, <span class="title">UNUserNotificationCenterDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter, </span></span></div><div class="line">                       willPresent notification: UNNotification, </div><div class="line">                       withCompletionHandler completionHandler: @escaping <span class="params">(UNNotificationPresentationOptions)</span> -&gt; <span class="type">Void</span>) </div><div class="line">    &#123;</div><div class="line">        completionHandler([.alert, .sound])</div><div class="line">        </div><div class="line">        <span class="comment">// 如果不想显示某个通知，可以直接用空 options 调用 completionHandler:</span></div><div class="line">        <span class="comment">// completionHandler([])</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现后，将 <code>NotificationHandler</code> 的实例赋值给 <code>UNUserNotificationCenter</code> 的 <code>delegate</code> 属性就可以了。没有特殊理由的话，AppDelegate 的 <code>application(_:didFinishLaunchingWithOptions:)</code> 就是一个不错的选择：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> notificationHandler = <span class="type">NotificationHandler</span>()</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="type">UNUserNotificationCenter</span>.current().delegate = notificationHandler</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对通知进行响应"><a href="#对通知进行响应" class="headerlink" title="对通知进行响应"></a>对通知进行响应</h4><p><code>UNUserNotificationCenterDelegate</code> 中还有一个方法，<code>userNotificationCenter(_:didReceive:withCompletionHandler:)</code>。这个代理方法会在用户与你推送的通知进行交互时被调用，包括用户通过通知打开了你的应用，或者点击或者触发了某个 action (我们之后会提到 actionable 的通知)。因为涉及到打开应用的行为，所以实现了这个方法的 delegate 必须在 <code>applicationDidFinishLaunching:</code> 返回前就完成设置，这也是我们之前推荐将 <code>NotificationHandler</code> 尽早进行赋值的理由。</p>
<p>一个最简单的实现自然是什么也不错，直接告诉系统你已经完成了所有工作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    completionHandler()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想让这个方法变得有趣一点的话，在创建通知的内容时，我们可以在请求中附带一些信息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()</div><div class="line">content.title = <span class="string">"Time Interval Notification"</span></div><div class="line">content.body = <span class="string">"My first notification"</span></div><div class="line">        </div><div class="line">content.userInfo = [<span class="string">"name"</span>: <span class="string">"onevcat"</span>]</div></pre></td></tr></table></figure>
<p>在该方法里，我们将获取到这个推送请求对应的 response，<code>UNNotificationResponse</code> 是一个几乎包括了通知的所有信息的对象，从中我们可以再次获取到 <code>userInfo</code> 中的信息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> name = response.notification.request.content.userInfo[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"I know it's you! <span class="subst">\(name)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">    completionHandler()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更好的消息是，远程推送的 payload 内的内容也会出现在这个 <code>userInfo</code> 中，这样一来，不论是本地推送还是远程推送，处理的路径得到了统一。通过 <code>userInfo</code> 的内容来决定页面跳转或者是进行其他操作，都会有很大空间。</p>
<h3 id="Actionable-通知发送和处理"><a href="#Actionable-通知发送和处理" class="headerlink" title="Actionable 通知发送和处理"></a>Actionable 通知发送和处理</h3><h4 id="注册-Category"><a href="#注册-Category" class="headerlink" title="注册 Category"></a>注册 Category</h4><p>iOS 8 和 9 中 Apple 引入了可以交互的通知，这是通过将一簇 action 放到一个 category 中，将这个 category 进行注册，最后在发送通知时将通知的 category 设置为要使用的 category 来实现的。</p>
<p><img src="/assets/images/2016/notification-category.png" alt=""></p>
<p>注册一个 category 非常容易：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">registerNotificationCategory</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> saySomethingCategory: <span class="type">UNNotificationCategory</span> = &#123;</div><div class="line">        <span class="comment">// 1</span></div><div class="line">        <span class="keyword">let</span> inputAction = <span class="type">UNTextInputNotificationAction</span>(</div><div class="line">            identifier: <span class="string">"action.input"</span>,</div><div class="line">            title: <span class="string">"Input"</span>,</div><div class="line">            options: [.foreground],</div><div class="line">            textInputButtonTitle: <span class="string">"Send"</span>,</div><div class="line">            textInputPlaceholder: <span class="string">"What do you want to say..."</span>)</div><div class="line">        </div><div class="line">        <span class="comment">// 2</span></div><div class="line">        <span class="keyword">let</span> goodbyeAction = <span class="type">UNNotificationAction</span>(</div><div class="line">            identifier: <span class="string">"action.goodbye"</span>,</div><div class="line">            title: <span class="string">"Goodbye"</span>,</div><div class="line">            options: [.foreground])</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> cancelAction = <span class="type">UNNotificationAction</span>(</div><div class="line">            identifier: <span class="string">"action.cancel"</span>,</div><div class="line">            title: <span class="string">"Cancel"</span>,</div><div class="line">            options: [.destructive])</div><div class="line">        </div><div class="line">        <span class="comment">// 3</span></div><div class="line">        <span class="keyword">return</span> <span class="type">UNNotificationCategory</span>(identifier:<span class="string">"saySomethingCategory"</span>, actions: [inputAction, goodbyeAction, cancelAction], intentIdentifiers: [], options: [.customDismissAction])</div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    <span class="type">UNUserNotificationCenter</span>.current().setNotificationCategories([saySomethingCategory])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>UNTextInputNotificationAction</code> 代表一个输入文本的 action，你可以自定义框的按钮 title 和 placeholder。你稍后会使用 <code>identifier</code> 来对 action 进行区分。</li>
<li>普通的 <code>UNNotificationAction</code> 对应标准的按钮。</li>
<li>为 category 指定一个 <code>identifier</code>，我们将在实际发送通知的时候用这个标识符进行设置，这样系统就知道这个通知对应哪个 category 了。</li>
</ol>
<p>当然，不要忘了在程序启动时调用这个方法进行注册：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    registerNotificationCategory()</div><div class="line">    <span class="type">UNUserNotificationCenter</span>.current().delegate = notificationHandler</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="发送一个带有-action-的通知"><a href="#发送一个带有-action-的通知" class="headerlink" title="发送一个带有 action 的通知"></a>发送一个带有 action 的通知</h4><p>在完成 category 注册后，发送一个 actionable 通知就非常简单了，只需要在创建 <code>UNNotificationContent</code> 时把 <code>categoryIdentifier</code> 设置为需要的 category id 即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">content.categoryIdentifier = <span class="string">"saySomethingCategory"</span></div></pre></td></tr></table></figure>
<p>尝试展示这个通知，在下拉或者使用 3D touch 展开通知后，就可以看到对应的 action 了：</p>
<p><img src="/assets/images/2016/notification-actions.png" alt=""></p>
<p>远程推送也可以使用 category，只需要在 payload 中添加 <code>category</code> 字段，并指定预先定义的 category id 就可以了：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"aps"</span>:&#123;</div><div class="line">    <span class="attr">"alert"</span>:<span class="string">"Please say something"</span>,</div><div class="line">    <span class="attr">"category"</span>:<span class="string">"saySomething"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="处理-actionable-通知"><a href="#处理-actionable-通知" class="headerlink" title="处理 actionable 通知"></a>处理 actionable 通知</h4><p>和普通的通知并无二致，actionable 通知也会走到 <code>didReceive</code> 的 delegate 方法，我们通过 request 中包含的 <code>categoryIdentifier</code> 和 response 里的 <code>actionIdentifier</code> 就可以轻易判定是哪个通知的哪个操作被执行了。对于 <code>UNTextInputNotificationAction</code> 触发的 response，直接将它转换为一个 <code>UNTextInputNotificationResponse</code>，就可以拿到其中的用户输入了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">userNotificationCenter</span><span class="params">(<span class="number">_</span> center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> category = <span class="type">UserNotificationCategoryType</span>(rawValue: response.notification.request.content.categoryIdentifier) &#123;</div><div class="line">        <span class="keyword">switch</span> category &#123;</div><div class="line">        <span class="keyword">case</span> .saySomething:</div><div class="line">            handleSaySomthing(response: response)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    completionHandler()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">handleSaySomthing</span><span class="params">(response: UNNotificationResponse)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> text: <span class="type">String</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> actionType = <span class="type">SaySomethingCategoryAction</span>(rawValue: response.actionIdentifier) &#123;</div><div class="line">        <span class="keyword">switch</span> actionType &#123;</div><div class="line">        <span class="keyword">case</span> .input: text = (response <span class="keyword">as</span>! <span class="type">UNTextInputNotificationResponse</span>).userText</div><div class="line">        <span class="keyword">case</span> .goodbye: text = <span class="string">"Goodbye"</span></div><div class="line">        <span class="keyword">case</span> .<span class="keyword">none</span>: text = <span class="string">""</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Only tap or clear. (You will not receive this callback when user clear your notification unless you set .customDismissAction as the option of category)</span></div><div class="line">        text = <span class="string">""</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> !text.isEmpty &#123;</div><div class="line">        <span class="type">UIAlertController</span>.showConfirmAlertFromTopViewController(message: <span class="string">"You just said <span class="subst">\(text)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码先判断通知响应是否属于 “saySomething”，然后从用户输入或者是选择中提取字符串，并且弹出一个 alert 作为响应结果。当然，更多的情况下我们会发送一个网络请求，或者是根据用户操作更新一些 UI 等。</p>
<blockquote>
<p>关于 Actionable 的通知，可以参考 Demo 中 <a href="https://github.com/onevcat/UserNotificationDemo/blob/master/UserNotificationDemo/ActionableViewController.swift" target="_blank" rel="external"><code>ActionableViewController</code></a> 的内容。</p>
</blockquote>
<h3 id="Notification-Extension"><a href="#Notification-Extension" class="headerlink" title="Notification Extension"></a>Notification Extension</h3><p>iOS 10 中添加了很多 extension，作为应用与系统整合的入口。与通知相关的 extension 有两个：Service Extension 和 Content Extension。前者可以让我们有机会在收到远程推送的通知后，展示之前对通知内容进行修改；后者可以用来自定义通知视图的样式。</p>
<p><img src="/assets/images/2016/notification-extensions.png" alt=""></p>
<h4 id="截取并修改通知内容"><a href="#截取并修改通知内容" class="headerlink" title="截取并修改通知内容"></a>截取并修改通知内容</h4><p><code>NotificationService</code> 的模板已经为我们进行了基本的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationService</span>: <span class="title">UNNotificationServiceExtension</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> contentHandler: ((<span class="type">UNNotificationContent</span>) -&gt; <span class="type">Void</span>)?</div><div class="line">    <span class="keyword">var</span> bestAttemptContent: <span class="type">UNMutableNotificationContent</span>?</div><div class="line">    </div><div class="line">    <span class="comment">// 1</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> request: UNNotificationRequest, withContentHandler contentHandler: @escaping <span class="params">(UNNotificationContent)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.contentHandler = contentHandler</div><div class="line">        bestAttemptContent = (request.content.mutableCopy() <span class="keyword">as</span>? <span class="type">UNMutableNotificationContent</span>)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> bestAttemptContent = bestAttemptContent &#123;</div><div class="line">            <span class="keyword">if</span> request.identifier == <span class="string">"mutableContent"</span> &#123;</div><div class="line">                bestAttemptContent.body = <span class="string">"<span class="subst">\(bestAttemptContent.body)</span>, onevcat"</span></div><div class="line">            &#125;</div><div class="line">            contentHandler(bestAttemptContent)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 2</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">serviceExtensionTimeWillExpire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">// Called just before the extension will be terminated by the system.</span></div><div class="line">        <span class="comment">// Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> contentHandler = contentHandler, <span class="keyword">let</span> bestAttemptContent =  bestAttemptContent &#123;</div><div class="line">            contentHandler(bestAttemptContent)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>didReceive:</code> 方法中有一个等待发送的通知请求，我们通过修改这个请求中的 content 内容，然后在限制的时间内将修改后的内容调用通过 <code>contentHandler</code> 返还给系统，就可以显示这个修改过的通知了。</li>
<li>在一定时间内没有调用 <code>contentHandler</code> 的话，系统会调用这个方法，来告诉你大限已到。你可以选择什么都不做，这样的话系统将当作什么都没发生，简单地显示原来的通知。可能你其实已经设置好了绝大部分内容，只是有很少一部分没有完成，这时你也可以像例子中这样调用 <code>contentHandler</code> 来显示一个变更“中途”的通知。</li>
</ol>
<p>Service Extension 现在只对远程推送的通知起效，你可以在推送 payload 中增加一个 <code>mutable-content</code> 值为 1 的项来启用内容修改：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"aps"</span>:&#123;</div><div class="line">    <span class="attr">"alert"</span>:&#123;</div><div class="line">      <span class="attr">"title"</span>:<span class="string">"Greetings"</span>,</div><div class="line">      <span class="attr">"body"</span>:<span class="string">"Long time no see"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"mutable-content"</span>:<span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 payload 的推送得到的结果，注意 body 后面附上了名字。</p>
<p><img src="/assets/images/2016/notification-mutable-content.png" alt=""></p>
<p>使用在本机截取推送并替换内容的方式，可以完成端到端 (end-to-end) 的推送加密。你在服务器推送 payload 中加入加密过的文本，在客户端接到通知后使用预先定义或者获取过的密钥进行解密，然后立即显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。</p>
<h4 id="在通知中展示图片-视频"><a href="#在通知中展示图片-视频" class="headerlink" title="在通知中展示图片/视频"></a>在通知中展示图片/视频</h4><p>相比于旧版本的通知，iOS 10 中另一个亮眼功能是多媒体的推送。开发者现在可以在通知中嵌入图片或者视频，这极大丰富了推送内容的可读性和趣味性。</p>
<p>为本地通知添加多媒体内容十分简单，只需要通过本地磁盘上的文件 URL 创建一个 <code>UNNotificationAttachment</code> 对象，然后将这个对象放到数组中赋值给 content 的 <code>attachments</code> 属性就行了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()</div><div class="line">content.title = <span class="string">"Image Notification"</span></div><div class="line">content.body = <span class="string">"Show me an image!"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> imageURL = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"image"</span>, withExtension: <span class="string">"jpg"</span>),</div><div class="line">   <span class="keyword">let</span> attachment = <span class="keyword">try</span>? <span class="type">UNNotificationAttachment</span>(identifier: <span class="string">"imageAttachment"</span>, url: imageURL, options: <span class="literal">nil</span>)</div><div class="line">&#123;</div><div class="line">    content.attachments = [attachment]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在显示时，横幅或者弹窗将附带设置的图片，使用 3D Touch pop 通知或者下拉通知显示详细内容时，图片也会被放大展示：</p>
<p><img src="/assets/images/2016/notification-thumbnail.png" alt=""> <img src="/assets/images/2016/notification-image.png" alt=""></p>
<p>除了图片以外，通知还支持音频以及视频。你可以将 MP3 或者 MP4 这样的文件提供给系统来在通知中进行展示和播放。不过，这些文件都有尺寸的限制，比如图片不能超过 10MB，视频不能超过 50MB 等，不过对于一般的能在通知中展示的内容来说，这个尺寸应该是绰绰有余了。关于支持的文件格式和尺寸，可以在<a href="https://developer.apple.com/reference/usernotifications/unnotificationattachment" target="_blank" rel="external">文档</a>中进行确认。在创建 <code>UNNotificationAttachment</code> 时，如果遇到了不支持的格式，SDK 也会抛出错误。</p>
<p>通过远程推送的方式，你也可以显示图片等多媒体内容。这要借助于上一节所提到的通过 Notification Service Extension 来修改推送通知内容的技术。一般做法是，我们在推送的 payload 中指定需要加载的图片资源地址，这个地址可以是应用 bundle 内已经存在的资源，也可以是网络的资源。不过因为在创建 <code>UNNotificationAttachment</code> 时我们只能使用本地资源，所以如果多媒体还不在本地的话，我们需要先将其下载到本地。在完成 <code>UNNotificationAttachment</code> 创建后，我们就可以和本地通知一样，将它设置给 <code>attachments</code> 属性，然后调用 <code>contentHandler</code> 了。</p>
<p>简单的示例 payload 如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"aps"</span>:&#123;</div><div class="line">    <span class="attr">"alert"</span>:&#123;</div><div class="line">      <span class="attr">"title"</span>:<span class="string">"Image Notification"</span>,</div><div class="line">      <span class="attr">"body"</span>:<span class="string">"Show me an image from web!"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"mutable-content"</span>:<span class="number">1</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"image"</span>: <span class="string">"https://onevcat.com/assets/images/background-cover.jpg"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>mutable-content</code> 表示我们会在接收到通知时对内容进行更改，<code>image</code> 指明了目标图片的地址。</p>
<p>在 <code>NotificationService</code> 里，加入如下代码来下载图片，并将其保存到磁盘缓存中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">downloadAndSave</span><span class="params">(url: URL, handler: @escaping <span class="params">(<span class="number">_</span> localURL: URL?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: url, completionHandler: &#123;</div><div class="line">        data, res, error <span class="keyword">in</span></div><div class="line">        </div><div class="line">        <span class="keyword">var</span> localURL: <span class="type">URL</span>? = <span class="literal">nil</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> data = data &#123;</div><div class="line">            <span class="keyword">let</span> ext = (url.absoluteString <span class="keyword">as</span> <span class="type">NSString</span>).pathExtension</div><div class="line">            <span class="keyword">let</span> cacheURL = <span class="type">URL</span>(fileURLWithPath: <span class="type">FileManager</span>.<span class="keyword">default</span>.cachesDirectory)</div><div class="line">            <span class="keyword">let</span> url = cacheURL.appendingPathComponent(url.absoluteString.md5).appendingPathExtension(ext)</div><div class="line"></div><div class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">try</span>? data.write(to: url) &#123;</div><div class="line">                localURL = url</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        handler(localURL)</div><div class="line">    &#125;)</div><div class="line">    </div><div class="line">    task.resume()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在 <code>didReceive:</code> 中，接收到这类通知时提取图片地址，下载，并生成 attachment，进行通知展示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> imageURLString = bestAttemptContent.userInfo[<span class="string">"image"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</div><div class="line">   <span class="keyword">let</span> <span class="type">URL</span> = <span class="type">URL</span>(string: imageURLString)</div><div class="line">&#123;</div><div class="line">    downloadAndSave(url: <span class="type">URL</span>) &#123; localURL <span class="keyword">in</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> localURL = localURL &#123;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">let</span> attachment = <span class="keyword">try</span> <span class="type">UNNotificationAttachment</span>(identifier: <span class="string">"image_downloaded"</span>, url: localURL, options: <span class="literal">nil</span>)</div><div class="line">                bestAttemptContent.attachments = [attachment]</div><div class="line">            &#125; <span class="keyword">catch</span> &#123;</div><div class="line">                <span class="built_in">print</span>(error)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        contentHandler(bestAttemptContent)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于在通知中展示图片或者视频，有几点想补充说明：</p>
<ul>
<li><code>UNNotificationContent</code> 的 <code>attachments</code> 虽然是一个数组，但是系统只会展示第一个 attachment 对象的内容。不过你依然可以发送多个 attachments，然后在要展示的时候再重新安排它们的顺序，以显示最符合情景的图片或者视频。另外，你也可能会在自定义通知展示 UI 时用到多个 attachment。我们接下来一节中会看到一个相关的例子。</li>
<li>在当前 beta (iOS 10 beta 4) 中，<code>serviceExtensionTimeWillExpire</code> 被调用之前，你有 30 秒时间来处理和更改通知内容。对于一般的图片来说，这个时间是足够的。但是如果你推送的是体积较大的视频内容，用户又恰巧处在糟糕的网络环境的话，很有可能无法及时下载完成。</li>
<li>如果你想在远程推送来的通知中显示应用 bundle 内的资源的话，要注意 extension 的 bundle 和 app main bundle 并不是一回事儿。你可以选择将图片资源放到 extension bundle 中，也可以选择放在 main bundle 里。总之，你需要保证能够获取到正确的，并且你具有读取权限的 url。关于从 extension 中访问 main bundle，可以参看<a href="http://stackoverflow.com/questions/26189060/get-the-main-app-bundle-from-within-extension" target="_blank" rel="external">这篇回答</a>。</li>
<li>系统在创建 attachement 时会根据提供的 url 后缀确定文件类型，如果没有后缀，或者后缀无法不正确的话，你可以在创建时通过 <code>UNNotificationAttachmentOptionsTypeHintKey</code> 来<a href="https://developer.apple.com/reference/usernotifications/unnotificationattachmentoptionstypehintkey" target="_blank" rel="external">指定资源类型</a>。</li>
<li>如果使用的图片和视频文件不在你的 bundle 内部，它们将被移动到系统的负责通知的文件夹下，然后在当通知被移除后删除。如果媒体文件在 bundle 内部，它们将被复制到通知文件夹下。每个应用能使用的媒体文件的文件大小总和是有限制，超过限制后创建 attachment 时将抛出异常。可能的所有错误可以在 <code>UNError</code> 中找到。</li>
<li><p>你可以访问一个已经创建的 attachment 的内容，但是要注意权限问题。可以使用 <code>startAccessingSecurityScopedResource</code> 来暂时获取以创建的 attachment 的访问权限。比如：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> content = notification.request.content</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> attachment = content.attachments.first &#123;  </div><div class="line">    <span class="keyword">if</span> attachment.url.startAccessingSecurityScopedResource() &#123;  </div><div class="line">        eventImage.image = <span class="type">UIImage</span>(contentsOfFile: attachment.url.path!)  </div><div class="line">        attachment.url.stopAccessingSecurityScopedResource()  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>关于 Service Extension 和多媒体通知的使用，可以参考 Demo 中 <a href="https://github.com/onevcat/UserNotificationDemo/blob/master/NotificationService/NotificationService.swift" target="_blank" rel="external"><code>NotificationService</code></a> 和 <a href="https://github.com/onevcat/UserNotificationDemo/blob/master/UserNotificationDemo/MediaViewController.swift" target="_blank" rel="external"><code>MediaViewController</code></a> 的内容。</p>
</blockquote>
<h4 id="自定义通知视图样式"><a href="#自定义通知视图样式" class="headerlink" title="自定义通知视图样式"></a>自定义通知视图样式</h4><p>iOS 10 SDK 新加的另一个 Content Extension 可以用来自定义通知的详细页面的视图。新建一个 Notification Content Extension，Xcode 为我们准备的模板中包含了一个实现了 <code>UNNotificationContentExtension</code> 的 <code>UIViewController</code> 子类。这个 extension 中有一个必须实现的方法 <code>didReceive(_:)</code>，在系统需要显示自定义样式的通知详情视图时，这个方法将被调用，你需要在其中配置你的 UI。而 UI 本身可以通过这个 extension 中的 MainInterface.storyboard 来进行定义。自定义 UI 的通知是和通知 category 绑定的，我们需要在 extension 的 Info.plist 里指定这个通知样式所对应的 category 标识符：</p>
<p><img src="/assets/images/2016/notification-content-info.png" alt=""></p>
<p>系统在接收到通知后会先查找有没有能够处理这类通知的 content extension，如果存在，那么就交给 extension 来进行处理。另外，在构建 UI 时，我们可以通过 Info.plist 控制通知详细视图的尺寸，以及是否显示原始的通知。关于 Content Extension 中的 Info.plist 的 key，可以在<a href="https://developer.apple.com/reference/usernotificationsui/unnotificationcontentextension" target="_blank" rel="external">这个文档</a>中找到详细信息。</p>
<p>虽然我们可以使用包括按钮在内的各种 UI，但是系统不允许我们对这些 UI 进行交互。点击通知视图 UI 本身会将我们导航到应用中，不过我们可以通过 action 的方式来对自定义 UI 进行更新。<code>UNNotificationContentExtension</code> 为我们提供了一个可选方法 <code>didReceive(_:completionHandler:)</code>，它会在用户选择了某个 action 时被调用，你有机会在这里更新通知的 UI。如果有 UI 更新，那么在方法的 <code>completionHandler</code> 中，开发者可以选择传递 <code>.doNotDismiss</code> 来保持通知继续被显示。如果没有继续显示的必要，可以选择 <code>.dismissAndForwardAction</code> 或者 <code>.dismiss</code>，前者将把通知的 action 继续传递给应用的 <code>UNUserNotificationCenterDelegate</code> 中的 <code>userNotificationCenter(:didReceive:withCompletionHandler)</code>，而后者将直接解散这个通知。</p>
<p>如果你的自定义 UI 包含视频等，你还可以实现 <code>UNNotificationContentExtension</code> 里的 <code>media</code> 开头的一系列属性，它将为你提供一些视频播放的控件和相关方法。</p>
<blockquote>
<p>关于 Content Extension 和自定义通知样式，可以参考 Demo 中 <a href="https://github.com/onevcat/UserNotificationDemo/blob/master/NotificationContent/NotificationViewController.swift" target="_blank" rel="external"><code>NotificationViewController</code></a> 和 <a href="https://github.com/onevcat/UserNotificationDemo/blob/master/UserNotificationDemo/CustomizeUIViewController.swift" target="_blank" rel="external"><code>CustomizeUIViewController</code></a> 的内容。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iOS 10 SDK 中对通知这块进行了 iOS 系统发布以来最大的一次重构，很多“老朋友”都被标记为了 deprecated：</p>
<h3 id="iOS-10-中被标为弃用的-API"><a href="#iOS-10-中被标为弃用的-API" class="headerlink" title="iOS 10 中被标为弃用的 API"></a>iOS 10 中被标为弃用的 API</h3><ul>
<li>UILocalNotification</li>
<li>UIMutableUserNotificationAction</li>
<li>UIMutableUserNotificationCategory</li>
<li>UIUserNotificationAction</li>
<li>UIUserNotificationCategory</li>
<li>UIUserNotificationSettings</li>
<li>handleActionWithIdentifier:forLocalNotification:</li>
<li>handleActionWithIdentifier:forRemoteNotification:</li>
<li>didReceiveLocalNotification:withCompletion:</li>
<li>didReceiveRemoteNotification:withCompletion:</li>
</ul>
<p>等一系列在 <code>UIKit</code> 中的发送和处理通知的类型及方法。</p>
<h3 id="现状以及尽快使用新的-API"><a href="#现状以及尽快使用新的-API" class="headerlink" title="现状以及尽快使用新的 API"></a>现状以及尽快使用新的 API</h3><p>相比于 iOS 早期时代的 API，新的 API 展现出了高度的模块化和统一特性，易用性也非常好，是一套更加先进的 API。如果有可能，特别是如果你的应用是重度依赖通知特性的话，直接从 iOS 10 开始可以让你充分使用在新通知体系的各种特性。</p>
<p>虽然原来的 API 都被标为弃用了，但是如果你需要支持 iOS 10 之前的系统的话，你还是需要使用原来的 API。我们可以使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> #available(iOS <span class="number">10.0</span>, *) &#123;</div><div class="line">    <span class="comment">// Use UserNotification</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>的方式来指针对 iOS 10 进行新通知的适配，并让 iOS 10 的用户享受到新通知带来的便利特性，然后在将来版本升级到只支持 iOS 10 以上时再移除掉所有被弃用的代码。对于优化和梳理通知相关代码来说，新 API 对代码设计和组织上带来的好处足以弥补适配上的麻烦，而且它还能为你的应用提供更好的通知特性和体验，何乐不为呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;p&gt;iOS 10 中以前杂乱的和通知相关的 API 都被统一了，现在开发者可以使用独立的 UserNotificatio
    
    </summary>
    
    
      <category term="能工巧匠集" scheme="http://maxmak.tk/tags/%E8%83%BD%E5%B7%A5%E5%B7%A7%E5%8C%A0%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>开发者所需要知道的 iOS8 SDK 新特性</title>
    <link href="http://maxmak.tk/2014/07/15/2014-07-15-developer-should-know-about-ios8/"/>
    <id>http://maxmak.tk/2014/07/15/2014-07-15-developer-should-know-about-ios8/</id>
    <published>2014-07-15T05:27:05.000Z</published>
    <updated>2017-03-28T10:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/images/2014/wwdc2014-badge.jpg" alt=""></p>
<p>WWDC 2014 已经过去一个多月。最激动人心的莫过于 Swift 这门新语言的发布，我在之前已经写了一些关于这么语言的<a href="http://onevcat.com/2014/06/my-opinion-about-swift/" target="_blank" rel="external">第一印象</a>和一些<a href="http://onevcat.com/2014/06/walk-in-swift/" target="_blank" rel="external">初步的探索</a>。在写这篇文章的时候，Swift 随着 beta 3 得到了重大的更新，而这门语言现在也还在剧烈的变化之中。对于 Swift，现在大家的探索才刚刚上路，很多背后的机制还并不是非常清楚，或者有可能发生巨大的变化，因此在这里和之后的几篇文章，直到稳定的 1.0 版本出现，我不再打算继续深入针对 Swift 写什么文章。这基本出于对未来可能的变化会容易误导读到文章的新人的考虑，而并不是说建议我们现在可以放下 Swift，而安心等待正式版本。在我的观念里，对于一个尚不稳定的版本的探索和研究，远比之后被动去接受别人的结果要来的有趣得多，理解也会深入得多。因此如果您有时间的话，建议还是能尽早接触和使用会比较好。Github 上有一个<a href="https://github.com/ksm/SwiftInFlux" target="_blank" rel="external">不错的 repo</a>，记录了 Swift 一路以来的变化，并探讨了不足以及以后可能的变化，希望深研 Swift 的同学不妨关注看看。</p>
<p>这篇总览先简要介绍下在我看来作为 iOS 开发者应该关注的开发时的变化，在之后一系列文章里我会对其中的某几个部分详细探讨一下，而其余的可能就在本文中做简介。总而言之，这次 WWDC 2014 的相关笔记（现在来说的话是暂定计划要写的内容）大概整理如下：</p>
<ul>
<li><a href="http://onevcat/2014/07/developer-should-know-about-ios8" target="_blank" rel="external">开发者所需要知道的 iOS8 SDK 新特性</a></li>
<li><a href="http://onevcat.com/2014/07/ios-ui-unique/" target="_blank" rel="external">iOS 界面开发的大一统</a></li>
<li><a href="http://onevcat.com/2014/08/notification-today-widget/" target="_blank" rel="external">iOS 通知中心扩展制作入门</a></li>
<li><a href="http://onevcat.com/2014/10/ib-customize-view/" target="_blank" rel="external">可视化开发，IB 的新时代</a></li>
<li>iOS 和 Mac 整合开发</li>
<li>通知中心和应用使用重心的改变</li>
</ul>
<hr>
<h2 id="应用扩展-Extension"><a href="#应用扩展-Extension" class="headerlink" title="应用扩展 (Extension)"></a>应用扩展 (Extension)</h2><p>这是一个千呼万唤始出来的特性，也是一个可以发挥无限想象力的特性。现在 Apple 允许我们在 app 中添加一个新的 target，用来提供一些扩展功能：比如在系统的通知中心中显示一个自己的 widget，在某些应用的 Action 中加入自己的操作，在分享按扭里加入自己的条目，更甚至于添加自定义的键盘等等。每一种操作对应这一个应用扩展的入口，在开发中我们只需要在工程中新建立一个对应相应入口的 target，就能从一个很好的模板开始进行一些列开发，来实现这些传统意义上可能需要越狱才能实现的功能。</p>
<p>对于应用扩展，Apple 将其定义为 App 的功能的自然延伸，因此不是单独存在的，而是随着应用本体的包作为附属而被一同下载和安装到用户的设备中的，用户需要在之后选择将其开启。另外，由于应用扩展和应用是属于两个不同的 target 的，因此它们之间的数据和操作上的交互遵循的是另一套原则。关于应用扩展的更详细的内容，我计划在之后通过一个通知中心的 today 小框体控件的例子来详细说明。</p>
<blockquote>
<p>专题相关笔记</p>
<p><a href="http://onevcat.com/2014/08/notification-today-widget/" target="_blank" rel="external">iOS 通知中心扩展制作入门</a></p>
</blockquote>
<h2 id="App-开发时的统一"><a href="#App-开发时的统一" class="headerlink" title="App 开发时的统一"></a>App 开发时的统一</h2><p>随着一代代的 iPhone 和 iPad 的出现，iOS 设备的屏幕尺寸也开始出现分裂的趋势。之前一套屏幕两个方向吃遍全世界的美好时光已然不再，现在至少已经有 3.5 寸，4寸和 10(7) 寸三种分辨率/尺寸的机型需要进行适配，再考虑到每个尺寸的横竖两种方向，以及日益呼声愈高的 4.7 寸和 5.5 寸的 iPhone，可以相见现在的布局方式已然不堪重负。虽然在 iOS 6 Apple 就推出了 Auto Layout 来辅助完成布局工作，解决了原来的相对布局的一些问题，但是在以绝对尺寸为度量的坐标系统中，难免还是有所掣肘。在 iOS 8 中，Apple 的工程师们可以说“极富想象力”地干脆把限制和表征屏幕尺寸的长宽数字给去掉了，取而代之使用 size classes 的概念，将长宽尺寸按照设备类型和方向归类为 regular 和 compact 两类。通过为不同的设备定义尺寸分类，用来定义同类型的操作特性，这使得开发者更容易利用一套 UI 来适配不同的屏幕。</p>
<p>iOS 8 在 UIKit 中添加了一整套使用 size classes 来进行布局的 API，并且将原有的比较复杂（或者说有些冗余）的 API 作废了。结合新的 Interface Builder 和 Auto Layout，可以说对于多尺寸屏幕的适配得到了前所未有的简化。</p>
<p>不仅如此，像是原来 iPad 专有的 SplitController 等也被以适应不同 regular 和 compact 的尺寸类型的形式 port 到了 iPhone 上，在程序设计方面两者更加统一了。另外，一直陪伴我们的 <code>UIAlertView</code> 和 <code>UIActionSheet</code> 这些老面孔也将退出舞台，取而代之全部统一以 UIViewController 来呈现。</p>
<p>这是一个好的开始，也是一个好的变化。可以看到 Apple 在避免平台碎片化上正在努力。</p>
<blockquote>
<p>专题相关笔记</p>
<p><a href="http://onevcat.com/2014/07/ios-ui-unique/" target="_blank" rel="external">iOS 界面开发的大一统</a></p>
<p><a href="http://onevcat.com/2014/10/ib-customize-view/" target="_blank" rel="external">可视化开发，IB 的新时代</a></p>
</blockquote>
<h2 id="iCloud-相关"><a href="#iCloud-相关" class="headerlink" title="iCloud 相关"></a>iCloud 相关</h2><p>作为帮主的最后一件作品，iCloud 其实非常可惜，一直没有能在 Apple 的生态圈中特别出彩。首先主要是由于 iCloud 相关的开发和 API 使用起来有一定难度，另外就是之前的 SDK 在和 iCloud 相关的各种 API 或多或少都有一些小问题。在 iOS 7 中 iCloud，特别是 iCloud 和 CoreData 结合的部分的 API 的稳定性和易用性得到了很大的改善。而在 iOS 8 中，Apple 更进一步，推出了全新的被称为 Cloud Kit 的框架。如果您熟悉或者使用过像 <a href="https://www.parse.com" target="_blank" rel="external">Parse</a> 或者 <a href="https://cn.avoscloud.com" target="_blank" rel="external">AVOS Cloud</a> 之类的 <a href="http://en.wikipedia.org/wiki/Backend_as_a_service" target="_blank" rel="external">BaaS</a> 的话，可能会对这个框架感到亲切。但是和传统的 BaaS 稍有不同的是，Cloud Kit 更多的是倾向于使用 iCloud 对数据进行集成。你可以不更改应用现有的数据模型和结构，而只是使用 Cloud Kit 来从云端获取数据或者向云端存储数据。</p>
<p>相比与 Parse 和 AVOS 的 API，由于可以和系统深度集成，有很多在其他类似 BaaS 中没有的特性 (比如订阅某个公共对象)。但是因为是 Apple 自家产品，其缺点也是显而易见并且致命的 – 你无法在非 Apple 的平台上使用这个框架。也就是说，如果你的应用火了，想接着出个安卓版的话，那就只能呵呵了。所以虽然 Cloud Kit 看起来很美好，而且基本等同于免费使用，但是因为平台的限制，而它所涉及的内容又是对跨平台需求很强又绕不开的数据，所以可能实际中能实用的机会并不太多。当然，如果应用是 for iOS only 的话，使用 Cloud Kit 应该是很不错的选择。</p>
<p>关于云端存储的另一个新变化是存储源的可变化。以前我们基本别无选择，想使用沙盒外的文件的话，要么就是 iCloud 同一个 container 内的文件，要么就需要来个像 Dropbox 这样的第三方库去做一堆登陆验证什么的。不论那种方式都可以说挺麻烦的。而现在随着 <a href="https://www.apple.com/cn/ios/ios8/icloud-drive/" target="_blank" rel="external">iCloud Drive</a> 的引入，在应用间共享访问文件就变得很容易了。更甚，我们现在可以使用 <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIDocumentPickerViewController_Class/index.html#//apple_ref/occ/cl/UIDocumentPickerViewController" target="_blank" rel="external">UIDocumentPickerViewController</a> 来从第三方存储 (以及第三方 app 通过应用扩展所实现的存储) 中选取文件。</p>
<h2 id="Handoff-及其他-iOS-与-Mac-的协同开发"><a href="#Handoff-及其他-iOS-与-Mac-的协同开发" class="headerlink" title="Handoff 及其他 iOS 与 Mac 的协同开发"></a>Handoff 及其他 iOS 与 Mac 的协同开发</h2><p>虽然 PC 市场一直疲软，但是得益于 iDevice 的销售和品牌接受度的回升，Mac 的销量反而逆市上扬。这点在国内尤为明显，确实可以感觉到身边开始使用 Mac 的人在逐渐变多，这对于我们这些 iOS 开发者来说其实是一个不错的机会。iOS 8 中的 Handoff 机制（就是可以在 Mac 上继续完成在 iOS 上半途的工作）给 for both iOS and Mac 的应用带来了一个不错的契合点和卖点。而近年来在整合两个系统上的动作，也可以看得出 Apple 确实希望利用庞大的 iOS 的开发人员资源来进一步完善和丰富 Mac。iOS 开发和 Mac 开发其实同根同源，因此在转换的时候并不是很困难的事情。</p>
<p>我们一直以来都可以写出跨两个平台的 Model 部分的代码，而只需要关心在表现上的区别。而现在 Cocoa 和 CocoaTouch 在官方支持自制 framework 后，利用 framework 来完成这一过程可以说更加简单了。</p>
<blockquote>
<p>专题相关笔记</p>
<p>iOS 和 Mac 整合开发</p>
</blockquote>
<h2 id="Health-Kit-和-Home-Kit"><a href="#Health-Kit-和-Home-Kit" class="headerlink" title="Health Kit 和 Home Kit"></a>Health Kit 和 Home Kit</h2><p>这是对应两个现在很热的领域 – 可穿戴式设备和智能家电 – 所加入的框架。基本上来说 Apple 想做的事情就是以 iOS 为基础，为其他 app 建立一个平台以及成为用户数据的管理者。</p>
<p>Health Kit 就是一个用户体征参数的数据库，第三方应用可以向用户申请权限使用其中的数据或是向其中汇报数据。而 Home Kit 则以家庭，房间和设备的组织形式来管理和控制家中适配了 Home Kit 的智能家电。这两个超级年轻的框架的 API 相对都还比较简单，结构也很好，相信稍有经验的 iOS 开发者都能在很快掌握用法。唯一的限制在于作为普通开发者（比如我这样的只能自己业余玩的）可能手边现在不会有合适的设备来进行测试，所以很多东西其实没有办法验证。不过对于 Home Kit，Apple给我们提供了一个模拟器来模拟智能家电设备，您可以在 Xcode 6 的 Open Developer Tool 菜单中找到 Home Kit Accessory Simulator。使用模拟器可以发现，添加并且控制自定义的智能家电，用来前期开发还是蛮方便的。</p>
<p>如果能入手一些适配于 Health Kit 或者 Home Kit 的设备的话，我可能会补充一些关于这方面的开发心得。</p>
<h2 id="游戏方面"><a href="#游戏方面" class="headerlink" title="游戏方面"></a>游戏方面</h2><p>最大的改变莫过于 Scene Kit 的加入了。不过游戏天生的容易跨平台的特性 (并且也有这方面的强烈需求)，与平台限制的 Sprite Kit 是冲突的，所以去年的 Sprite Kit 也还没多少人用。暂时看来这个世界现在是，并且在一段时间内还会是被 Cocos2dx/Unity 所统治的。Scene Kit 的未来估计会和 Sprite Kit 比较类似，作为对于一直进行 iOS 应用开发的开发者来说，有着不需要学习和熟悉新语言的优势，容易与系统的其他框架进行集成，所以用来转型还算不错的选择。但除此之外其他方面可能也并没有多少可以吸引人的地方了。</p>
<p>另一个重大改变是对于 A7 和以上级别的 GPU 推出了一套全新的称为 Metal 的绘制 API，从 Keynote 的 Zen Garden 的演示来看，Metal 的性能毋庸置疑是令人折服的，Metal 的渲染方式和着色器也相当有趣。但是其实这些内容更多地是偏向底层以及面向引擎开发的，对于使用游戏引擎来制作游戏的大多数开发者来说，并不需要知道或者理解其中的东西。在 A7 的芯片下使用 Apple 自家的 Sprite Kit 或者 Scene Kit 的话，就可以直接受益于 Metal，而其他一些知名的第三方引擎，比如 Unity 和 UE 也都会在 iOS 8 推出后支持 Metal。因此，作为引擎使用者，并不需要做出除了升级开发使用的游戏引擎之外的任何改变。</p>
<h2 id="其他重要改动"><a href="#其他重要改动" class="headerlink" title="其他重要改动"></a>其他重要改动</h2><h3 id="Local-和-Remote-通知的变化"><a href="#Local-和-Remote-通知的变化" class="headerlink" title="Local 和 Remote 通知的变化"></a>Local 和 Remote 通知的变化</h3><p>现在需要显示 UI 或者播放声音的通知，包括 Local 通知也需要实现弹窗获得用户许可了。使用 <code>-registerUserNotificationSettings:</code> 来向用户获取许可。作为补偿，现在对于不需要打扰用户（也就是 iOS 7 加入的静默通知）的类型不再需要弹框获取用户许可。不过因为本地推送是需要许可的，所以无论怎样如果你想要依靠通知来提高用户留存率的话，现在都绕不开用户许可了。</p>
<p>另外，通知中心加入了非常方便的 Action 特性，用户可以在收到通知后，在不打开应用的情况下完成一些操作。可以说配合通知中心的 Today 扩展，用户现在在很可能可以在不打开应用的情况下就获取到他们想要的信息，并完成互动。这对于开发者可以说是一件喜忧参半的事情，一方面我们可以给用户提供更好更快的使用体验，但是另一方面这将降低用户打开应用的意愿。不过 Apple 现在的总体思路还是 app 的体验才是最重要的，所以正确的道路应该还是优先做好 app 的体验，并且摸索一个应用和通知之间的平衡点，让大家都满意。</p>
<blockquote>
<p>专题相关笔记</p>
<p>通知中心和应用使用重心的改变</p>
</blockquote>
<h3 id="CoreLocation"><a href="#CoreLocation" class="headerlink" title="CoreLocation"></a>CoreLocation</h3><p>CoreLocation 室内定位。现在 CL 可以给出在建筑物中的楼层定位信息了，直接访问 <code>CLLocation</code> 实例的 <code>floor</code>，如果当前位置可用的话，会返回一个包含位置信息的非 nil 的 <code>CLFloor</code> 以标识当前楼层。这个使得定位应用的可能性大大扩展了，想象一下在复杂的地铁站或者大厦里迷路的时候，还可以依赖定位系统，幸福感涌上心头啊。</p>
<h3 id="Touch-ID"><a href="#Touch-ID" class="headerlink" title="Touch ID"></a>Touch ID</h3><p>Touch ID API，说是开放了 Touch ID 的验证，但是实际上能做的事情还是比较有限。因为现在提供的 API 只能验证用户是不是手机主人本人，而不能给出一个识别的标志或者唯一编码，所以想用 Touch ID 做注册登陆什么的话可能还是不太现实。不过在进行支付验证之类的已登录后的再次确认操作时就比较好用。现在看来的话这组 API 就是为了简化像 Paypal 或者支付宝这样的第三方支付和确认的流程的。希望之后能继续放开，如果能给一个唯一标识的话，也许就可以干掉整个讨厌的注册和登陆系统了。</p>
<h3 id="相机和照片"><a href="#相机和照片" class="headerlink" title="相机和照片"></a>相机和照片</h3><p>新增加了 Photos.framework 框架，这个框架用于与系统内置的 Photo 应用进行交互，不仅可以替代原来的 Assets Library 作为照片和视频的选取，还能与 iCloud 照片流进行交互。除此之外，一个很重要的特性是还可以监听其他应用对于照片的改变，可以说整个框架非常灵活。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/images/2014/wwdc2014-badge.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;WWDC 2014 已经过去一个多月。最激动人心的莫过于 Swift 这门新语言的发布，我在之前已经写了一些关于这么语言的&lt;a href=&quot;ht
    
    </summary>
    
    
      <category term="能工巧匠集" scheme="http://maxmak.tk/tags/%E8%83%BD%E5%B7%A5%E5%B7%A7%E5%8C%A0%E9%9B%86/"/>
    
  </entry>
  
</feed>
