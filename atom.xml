<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MaxMak&#39;s House</title>
  <subtitle>iOS Developer|LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maxsmak.com/"/>
  <updated>2017-08-30T09:51:13.000Z</updated>
  <id>http://maxsmak.com/</id>
  
  <author>
    <name>Max Mak</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见设计模式</title>
    <link href="http://maxsmak.com/2017/08/29/DesignPatterns/"/>
    <id>http://maxsmak.com/2017/08/29/DesignPatterns/</id>
    <published>2017-08-29T06:10:39.000Z</published>
    <updated>2017-08-30T09:51:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h1><blockquote>
<p>开发中不管任何语言，面向对象语言在设计模式上是相通的，不过就是在设计模式的具体实现上语法之间有差异而已，接下来我会用swift进行讲解.</p>
</blockquote>
<h3 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式(Strategy)"></a>策略模式(Strategy)</h3><blockquote>
<p>定义一系列的算法类，然后分别将它们每一个算法封装起来，让它们相互替换，在这模式下使算法独立于使用者而变化。也是一种对象行为模式。(也称<code>政策模式</code>)</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 策略模式(Strategy)</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Strategy</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">currentObjectName</span><span class="params">()</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyNormal</span>:<span class="title">Strategy</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">currentObjectName</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(StrategyNormal.<span class="keyword">self</span>)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategySelected</span>:<span class="title">Strategy</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">currentObjectName</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(StrategySelected.<span class="keyword">self</span>)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrategyHighlighted</span>:<span class="title">Strategy</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">currentObjectName</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(StrategyHighlighted.<span class="keyword">self</span>)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">StrategyStyle</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">case</span> normal,selected,highlighted</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> obj:<span class="type">Strategy</span></div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> style:<span class="type">StrategyStyle</span>) &#123;</div><div class="line">        <span class="keyword">switch</span> style &#123;</div><div class="line">        <span class="keyword">case</span> .normal:</div><div class="line">            <span class="keyword">self</span>.obj = <span class="type">StrategyNormal</span>()</div><div class="line">        <span class="keyword">case</span> .selected:</div><div class="line">            <span class="keyword">self</span>.obj = <span class="type">StrategySelected</span>()</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">self</span>.obj = <span class="type">StrategyHighlighted</span>()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">self</span>.obj.currentObjectName()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> normal = <span class="type">Context</span>(.normal)</div><div class="line">normal.execute() <span class="comment">//StrategyNormal</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> selected = <span class="type">Context</span>(.selected)</div><div class="line">selected.execute() <span class="comment">//StrategyNormal</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> highlighted = <span class="type">Context</span>(.highlighted)</div><div class="line">highlighted.execute() <span class="comment">//StrategyHighlighted</span></div></pre></td></tr></table></figure>
<h5 id="策略模式优点"><a href="#策略模式优点" class="headerlink" title="策略模式优点"></a>策略模式优点</h5><ul>
<li>完全符合”开闭原则<sup>[1]</sup>“.</li>
<li>结构清晰，使用简单</li>
<li>提供一种替换继承的办法，符合“单一职责原则<sup>[2]</sup>”</li>
</ul>
<h5 id="策略模式缺点"><a href="#策略模式缺点" class="headerlink" title="策略模式缺点"></a>策略模式缺点</h5><ul>
<li>随着策略的增加，产生很多具体策略类.</li>
<li>无法同时使用多个策略类.</li>
</ul>
<hr>
<h3 id="简单工厂模式-Simple-Factory-Pattern"><a href="#简单工厂模式-Simple-Factory-Pattern" class="headerlink" title="简单工厂模式(Simple Factory Pattern)"></a>简单工厂模式(Simple Factory Pattern)</h3><blockquote>
<p>又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 简单工厂模式(Simple Factory Pattern)</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Calculate</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startCalculate</span><span class="params">(numA:Float,numB:Float)</span></span> -&gt; <span class="type">Float</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCalculate</span>:<span class="title">Calculate</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startCalculate</span><span class="params">(numA:Float,numB:Float)</span></span> -&gt; <span class="type">Float</span>&#123;</div><div class="line">        <span class="keyword">return</span> numA + numB</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinusCalculate</span>:<span class="title">Calculate</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startCalculate</span><span class="params">(numA:Float,numB:Float)</span></span> -&gt; <span class="type">Float</span>&#123;</div><div class="line">        <span class="keyword">return</span> numA - numB</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiplyCalculate</span>:<span class="title">Calculate</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startCalculate</span><span class="params">(numA:Float,numB:Float)</span></span> -&gt; <span class="type">Float</span>&#123;</div><div class="line">        <span class="keyword">return</span> numA * numB</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DivideCalculate</span>:<span class="title">Calculate</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startCalculate</span><span class="params">(numA:Float,numB:Float)</span></span> -&gt; <span class="type">Float</span>&#123;</div><div class="line">        <span class="keyword">return</span> numA / numB</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CalculateStyle</span></span>&#123;</div><div class="line">    <span class="keyword">case</span> add,minus,divide,multiply</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalcuteFactory</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">createCalcute</span><span class="params">(<span class="number">_</span> style:CalculateStyle)</span></span> - <span class="type">Calculate</span>&#123;</div><div class="line">        <span class="keyword">switch</span> style &#123;</div><div class="line">        <span class="keyword">case</span> .add:</div><div class="line">            <span class="keyword">return</span> <span class="type">AddCalculate</span>()</div><div class="line">        <span class="keyword">case</span> .minus:</div><div class="line">            <span class="keyword">return</span> <span class="type">MinusCalculate</span>()</div><div class="line">        <span class="keyword">case</span> .multiply:</div><div class="line">            <span class="keyword">return</span> <span class="type">MultiplyCalculate</span>()</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="type">DivideCalculate</span>()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> add  = <span class="type">CalcuteFactory</span>.createCalcute(.add) </div><div class="line">add.startCalculate(numA: <span class="number">10</span>, numB: <span class="number">10</span>) <span class="comment">// 20</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> minus = <span class="type">CalcuteFactory</span>.createCalcute(.minus) </div><div class="line">minus.startCalculate(numA: <span class="number">20</span>, numB: <span class="number">10</span>) <span class="comment">// 10</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> multiply = <span class="type">CalcuteFactory</span>.createCalcute(.multiply) </div><div class="line">multiply.startCalculate(numA: <span class="number">10</span>, numB: <span class="number">10</span>) <span class="comment">// 100</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> divide = <span class="type">CalcuteFactory</span>.createCalcute(.divide)</div><div class="line">divide.startCalculate(numA: <span class="number">10</span>, numB: <span class="number">10</span>) <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h5 id="简单工厂模式优点"><a href="#简单工厂模式优点" class="headerlink" title="简单工厂模式优点"></a>简单工厂模式优点</h5><ul>
<li>工厂类可以决定在什么时候创建哪一个产品类的实例，使用者可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li>
<li>使用者无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li>通过引入配置文件，可以在不修改任何使用者代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
</ul>
<h5 id="简单工厂模式缺点"><a href="#简单工厂模式缺点" class="headerlink" title="简单工厂模式缺点"></a>简单工厂模式缺点</h5><ul>
<li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。<br>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ul>
<hr>
<h3 id="看到这里可能有人会问策略模式和简单工厂模式有什么区别？"><a href="#看到这里可能有人会问策略模式和简单工厂模式有什么区别？" class="headerlink" title="看到这里可能有人会问策略模式和简单工厂模式有什么区别？"></a>看到这里可能有人会问策略模式和简单工厂模式有什么区别？</h3><blockquote>
<p>策略模式和简单工厂模式看起来非常相似,从使用这两种模式的角度来看，我们会发现在<code>简单工厂模式</code> 中我们只需要传递相应的条件就能得到想要的对象，然后使用者通过这个对象实现算法操作。而在<code>策略模式</code>下，使用时必须首先创建一个想使用的类对象，然后将该对象最为参数传递进去，通过该对象调用不同的算法。在简单工厂模式中实现了通过条件选取一个类去实例化对象，策略模式则将选取相应对象的工作交给模式的使用者，它本身不去做选取工作。</p>
</blockquote>
<hr>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><blockquote>
<p>后补</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">后补</div></pre></td></tr></table></figure>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><blockquote>
<p>后补</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">后补</div></pre></td></tr></table></figure>
<p> <sub>[1]<sub> <strong>开放-封闭原则(OCP):</strong> 类对扩展开放，而对修改封闭。</sub></sub></p>
<p> <sub>[2]<sub> <strong>单一职责原则(SRP):</strong> 规定每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来.</sub></sub></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常见设计模式&quot;&gt;&lt;a href=&quot;#常见设计模式&quot; class=&quot;headerlink&quot; title=&quot;常见设计模式&quot;&gt;&lt;/a&gt;常见设计模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;开发中不管任何语言，面向对象语言在设计模式上是相通的，不过就是在设计模式的具体实现
    
    </summary>
    
    
      <category term="设计模式" scheme="http://maxsmak.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈字节序和字节对齐</title>
    <link href="http://maxsmak.com/2015/12/15/Discussed/"/>
    <id>http://maxsmak.com/2015/12/15/Discussed/</id>
    <published>2015-12-15T07:30:36.000Z</published>
    <updated>2017-04-12T04:23:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做智能硬件App开发的过程中，手机端和蓝牙模块之间需要进行传输数据。蓝牙4.0低功耗模式数据传输速度很慢，以我们现在使用的蓝牙模块为例，传输速度大概只有大约1K/s，比起网络传输动辄几百K/s甚至上兆的速度真的是相差甚远。所以为了加快数据的传输速度唯一的办法就是减少要传输的数据的大小了。既然要减少数据量，那我们在网络请求中很常用的xml和json格式就不能用了。因为它里面有很多冗余的数据比如“{}[]”这一类的符号、字段的名称啊之类的信息。因此使用结构体作为数据的载体就是比较符合需求的方式了。</p>
<h2 id="结构体和NSData互转"><a href="#结构体和NSData互转" class="headerlink" title="结构体和NSData互转"></a>结构体和NSData互转</h2><p>iOS的CoreBluetooth框架发送和接收数据都需要使用NSData对象，其实NSData对象和结构体之间很容易进行转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 结构体 -&gt; NSData</div><div class="line">TestStruct test = &#123;1, 2, 3, 4, 5&#125;;</div><div class="line">NSData *data = [NSData dataWithBytes:&amp;test length:sizeof(TestStruct)];</div><div class="line">// NSDta -&gt; 结构体</div><div class="line">TestStruct test;</div><div class="line">[data getBytes:&amp;test length:sizeof(TestStruct)];</div></pre></td></tr></table></figure>
<p>实际使用的过程中你会发现有时候数据并不对，这就涉及到下面要说的字节序和字节对齐的问题了。如果要保证结构体和NSData的互相转换能够成功，就要确保互相通信的各个平台的字节序和字节对齐方式要统一。</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。</p>
<p>而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序（Little Endian）；反之则称大端序（Big Endian）。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。</p>
<p>例如假设上述变量x类型为int，位于地址0x100处，它的十六进制为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,..。而小端法将是：0x100: 67, 0x101: 45,..。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint32_t</span> a = <span class="number">0x12345678</span>;</div><div class="line">NSLog(@<span class="string">"%@"</span>, [NSData dataWithBytes:&amp;a length:<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)]);</div></pre></td></tr></table></figure>
<p>由于Mac和iOS都是采用的小端序，所以下面的代码的输出结果为<code>&lt;78563412&gt;</code></p>
<h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>先来看一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">uint64_t a;</div><div class="line">uint8_t  b;</div><div class="line">uint32_t c;</div><div class="line">uint8_t  d;</div><div class="line">uint16_t e;</div><div class="line">&#125; TestStruct;</div><div class="line">TestStruct test = &#123;1, 2, 3, 4, 5&#125;;</div><div class="line">NSUInteger length = sizeof(TestStruct);</div><div class="line">NSLog(@&quot;%ld %@&quot;, length, [NSData dataWithBytes:&amp;test length:length]);</div></pre></td></tr></table></figure>
<p>乍一看length不应该是8+1+4+1+2=16个字节吗？但是实际的输出的结果是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">24 &lt;01000000 00000000 02000000 03000000 04000500 00000000&gt;</div></pre></td></tr></table></figure>
<p>这是为什么呢？这就不得不说一说字节对齐了。</p>
<p><strong>为什么要进行字节对齐</strong></p>
<p>在计算机中数据存储和传输以位(bit)为单位，每8个位bit组成1个字节(Byte)。32位计算机的字长为32位，即4个字节；对应的，64位计算机的字长为64位，即8个字节。计算机系统对基本类型数据在内存中存放的位置有限制，要求这些数据的起始地址的值是某个数k的倍数，这就是所谓的内存对齐，而这个k则被称为该数据类型的对齐模数(alignment modulus)。</p>
<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数 据。显然在读取效率上下降很多。</p>
<p><strong>如何对齐</strong></p>
<ol>
<li>结构体的起始位置的偏移量必须是能够被该结构体中最大的数据类型所整除。</li>
<li>每个数据成员存储的起始位置的偏移量是自身大小的整数倍(比如int在32位机为4字节，则int型成员要从4的整数倍地址开始存储)。</li>
<li>结构体总大小（也就是sizeof的结果），必须是该结构体成员中最大的对齐模数的整数倍。若不满足，会根据需要自动填充空缺的字节。</li>
<li>结构体包含另一个结构体成员，则被包含的结构体成员要从其原始结构体内部最大对齐模数的整数倍地址开始存储。(比如struct a里存有struct b，b里有char,int,double等元素,那b应该从8的整数倍开始存储。)</li>
<li>结构体包含数组成员，比如char a[3],它的对齐方式和分别写3个char是一样的，也就是说它还是按一个字节对齐。如果写：typedef char Array[3],Array这种类型的对齐方式还是按一个字节对齐，而不是按它的长度3对齐。</li>
<li>结构体包含共用体成员，则该共用体成员要从其原始共用体内部最大对齐模数的整数倍地址开始存储。</li>
</ol>
<p>根据上面的对齐规则，成员a的起始位置偏移量为0，长度为8个字节；成员b的偏移量为8，长度为1个字节；成员c的偏移量为8+1=9，9无法整除成员c的长度4，所以在b和c之间自动填充空间对齐c的偏移量到12；成员d的偏移量为12＋4=16，长度为一个字节；成员e的偏移量为16+1=17，17无法整除e的长度2，自动对齐e的偏移量至18；整个结构体的长度为18+2=20个字节，无法整除结构体中最大的数据类型的长度8，因此自动填充空间至24个字节。</p>
<p>前面说过，字节对齐对CPU读取内存的效率会有很大的提升。但是不同平台，不同的编译器可能会有不同的对齐方式。如果对齐方式不同，我们使用结构体进行数据的传输就会出现问题。统一对齐方式的最简单的方法就是采用1字节对齐。1字节对齐其实就相当于是不进行对齐，这样做就降低了CPU读取内存的效率，不过相对于数据传输的便利，这点损耗无足轻重。那么怎么让编译器不进行对齐操作呢？只需要在结构体声明的时候加一个<br><code>__attribute__((packed))</code> 例如下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">uint64_t a;</div><div class="line">uint8_t  b;</div><div class="line">uint32_t c;</div><div class="line">uint8_t  d;</div><div class="line">uint16_t e;</div><div class="line">&#125; __attribute__((packed)) TestStruct;</div><div class="line">TestStruct test = &#123;1, 2, 3, 4, 5&#125;;</div><div class="line">NSUInteger length = sizeof(TestStruct);</div><div class="line">NSLog(@&quot;%ld %@&quot;, length, [NSData dataWithBytes:&amp;test length:length]);</div></pre></td></tr></table></figure>
<p>加上这个之后输出结果就变成了</p>
<p><code>16 &lt;01000000 00000000 02030000 00040500&gt;</code></p>
<p>这下就跟我们预想的一致了。</p>
<p>参考资料：</p>
<p><a href="https://zh.wikipedia.org/zh/字节序" target="_blank" rel="external">维基百科：字节序</a></p>
<p><a href="http://blog.csdn.net/baidu_31364929/article/details/49383623" target="_blank" rel="external">iOS开发关系结构体分配空间</a></p>
<p><a href="http://skx926.com/2016/07/31/byte-order/" target="_blank" rel="external">C++结构体字节对齐</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做智能硬件App开发的过程中，手机端和蓝牙模块之间需要进行传输数据。蓝牙4.0低功耗模式数据传输速度很慢，以我们现在使用的蓝牙模块为例，传输速度大概只有大约1K/s，比起网络传输动辄几百K/s甚至上兆的速度真的是相差甚远。所以为了加快数据的传输速度唯一的办法就是减少要传输
    
    </summary>
    
    
      <category term="iOS Development" scheme="http://maxsmak.com/tags/iOS-Development/"/>
    
  </entry>
  
  <entry>
    <title>指针</title>
    <link href="http://maxsmak.com/2015/10/02/Pointer/"/>
    <id>http://maxsmak.com/2015/10/02/Pointer/</id>
    <published>2015-10-02T03:09:16.000Z</published>
    <updated>2017-05-22T17:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个使用Objective-C的iOS开发者，指针对很多人来说却是最熟悉的陌生人–虽然每天都在用，但是却对它了解的不是很多。那么指针到底是什么呢？</p>
<blockquote>
<p>指针即指针变量，是一个存储变量内存地址的变量。</p>
</blockquote>
<p>这句话可能有点绕，我们举个例子来说一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;a;</div></pre></td></tr></table></figure>
<p>上面的代码首先声明了一个<code>int</code>类型的变量<code>a</code>，它的值为<code>0</code>。然后又声明了一个指针类型的变量<code>p</code>，<code>p</code>这个变量存储的值就是<code>a</code>变量的内存地址。</p>
<h2 id="C-中的引用"><a href="#C-中的引用" class="headerlink" title="C++中的引用"></a>C++中的引用</h2><blockquote>
<p>引用是变量的别名。</p>
</blockquote>
<p>我们同样举个例子来说一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> &amp;b = a;</div></pre></td></tr></table></figure>
<p>首先声明了一个<code>int</code>类型的变量<code>a</code>，它的值为<code>0</code>，然后又声明了一个<code>a</code>的引用<code>b</code>，<code>b</code>只是<code>a</code>的一个别名而已，并没有占用内存空间。实际上他们是同一个同西，在内存中占用同样的一个存储单元。</p>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>除了在定义上的区别，他们还有很多不同：</p>
<ol>
<li>有<code>const</code>指针，没有<code>const</code>引用。</li>
<li>指针可以有很多级，而引用只有一级（比如<code>int **p</code>是合法的，而<code>int &amp;&amp;b</code>是不合法的）。</li>
<li>指针可以为空，而引用不能为空，定义的时候必须对其进行初始化。</li>
<li>指针的值可以在初始化之后改变，而引用在初始化之后就不能变了。<br><code>sizeof(引用)</code>得到的是引用所表示的变量的大小，而<code>sizeof(指针)</code>得到的是指针本身的大小。</li>
</ol>
<h2 id="令人迷惑的-和-amp"><a href="#令人迷惑的-和-amp" class="headerlink" title="令人迷惑的*和&amp;"></a>令人迷惑的*和&amp;</h2><p><code>*</code>有两种含义，表示乘法和指针。<code>&amp;</code>有点复杂，它既表示位运算的与，又表示取地址，还表示引用，两个<code>&amp;</code>拼在一起<code>&amp;&amp;</code>又表示逻辑运算的且（天哪，为什么它的事情这么多！）。我们来看一段代码压压惊：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;a;</div><div class="line">*p = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> &amp;b = b;</div><div class="line">b = <span class="number">2</span>;</div></pre></td></tr></table></figure>
<p>第一行没啥说的，我们来看第二行：<code>int *p = &amp;a;</code>表示的是声明一个int类型的名叫p的指针变量并把a的地址赋给它，所以这行代码其实应该写成这样<code>int* p = &amp;a</code>。但是为什么我们一般要写成第一种形式呢？其实是为了防止引起歧义。比如<code>int* p, p1;</code>，这里的p1到底是指针类型呢还是int类型？这样写的话很容易让人感觉p1是指针类型的，而实际上它是<code>int</code>类型的。所以为了防止产生歧义，要声明两个指针我们就要写成这样<code>int *p, *p1;</code>。</p>
<p>说的好像很有道理的样子，那么第二行又是什么鬼？<code>*p</code>不是表示指针吗？为什么会给它赋值<code>1</code>？好吧，其实<code>p</code>才是指针，这里的<code>*</code>是解引用的意思，为了不跟上面说的引用产生歧义，你可以把它理解成解指针。所以<code>*p</code>指的是解引用，也就是根据p中所存储的内存地址来拿到p所指向的内存空间然后写入整数<code>1</code>。</p>
<p>所以同样的<code>*</code>号在变量声明的时候其实只是为了告诉编译器你要声明的变量是一个指针类型的变量，仅此而已。而在使用的时候<code>*</code>号表示的是引用的意思。</p>
<p><code>&amp;</code>号在声明的时候也同样只是为了告诉编译器你要创建一个变量的别名，与<code>*</code>号不同的是在使用的时候并不需要解引用之类的操作，直接使用引用名即可（如代码第五行所示）。需要注意的是如果在使用时候在变量名前加上<code>&amp;</code>符号就表示取这个变量的地址（如代码第二行所示）。</p>
<h2 id="值传递、指针传递、引用传递"><a href="#值传递、指针传递、引用传递" class="headerlink" title="值传递、指针传递、引用传递"></a>值传递、指针传递、引用传递</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    a++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase1</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</div><div class="line">    (*p)++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase2</span><span class="params">(<span class="keyword">int</span> &amp;b)</span> </span>&#123;</div><div class="line">    b++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    increase(a);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</div><div class="line">    <span class="keyword">int</span> *p = &amp;a;</div><div class="line">    increase1(p);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</div><div class="line">    <span class="keyword">int</span> &amp;b = a;</div><div class="line">    increase2(b);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码中的三个函数分别对应<code>值传递</code>、<code>指针传递</code>和<code>引用传递</code>，输出结果为<code>0 1 2</code>。说明第一个函数并没有改变<code>a</code>的值，是因为在<code>值传递的过程中会对传递的变量进行一次拷贝</code>，<code>increase</code>函数改变的不是<code>a</code>而是<code>a</code>的拷贝，并不会对<code>a</code>造成影响。既然值传递会进行拷贝，那么指针也是一个变量，指针传递的过程中应该也会对指针进行拷贝。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase1</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, p);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, &amp;p);</div><div class="line">    (*p)++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> *p = &amp;a;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, p);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, &amp;p);</div><div class="line">    increase1(p);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码输出结果为<code>5FBFF74C 5FBFF740 5FBFF74C 5FBFF718</code>，我们发现传递前和传递后指针<code>p</code>的值没有发生变化，但是<code>p</code>的地址却发生了变化。这说明指针传递的过程中也会发生拷贝，不过拷贝的是指针，而指针所指向的内存地址不会发生改变，这也是变量<code>a</code>的值能够被修改的原因。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase2</span><span class="params">(<span class="keyword">int</span> &amp;b)</span> </span>&#123;</div><div class="line">    b++;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, &amp;b);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, &amp;a);</div><div class="line">    increase2(a);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码的输出结果为<code>0 5FBFF74C 1 5FBFF74C</code>，这说明引用传递的过程中并没有发生值拷贝，传过去的引用和原来的变量是同一个东西，所以对它的修改就是对<code>a</code>的修改。</p>
<h2 id="关于NSError"><a href="#关于NSError" class="headerlink" title="关于NSError"></a>关于NSError</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSError *error;</div><div class="line">[[NSFileManager defaultManager] moveItemAtPath:srcPath toPath:dstPath error:&amp;error];</div><div class="line">if (error) &#123;</div><div class="line">    // handle error.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开发过程中经常会用到类似上面的代码，大家都知道NSError是这么用的，但是很多初学者对于为什么这样写却说不出个所以然。我们首先来看一下这个方法的声明<code>- (BOOL)moveItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error;</code>，通过这个方法的声明我们可以知道这里其实需要的是一个<code>NSError**</code>类型的参数。所以这段代码的意思是先创建一个<code>NSError</code>类型的指针变量<code>error</code>（并没有创建<code>NSError</code>对象），然后把它的地址传递过去，当<code>NSFileManager</code>对象在执行的过程中发生了错误就会创建一个<code>NSError</code>对象并把它的地址写入我们之前创建的<code>error</code>指针的内存空间，也就是让<code>error</code>指针指向新创建的<code>NSError</code>对象。</p>
<p>有人可能会问这里为什么要用二级指针<code>NSError**</code>，而不是用用一级指针<code>NSError*</code>？我觉得有以下两点原因：</p>
<ol>
<li>节省内存。如果使用一级指针，无论错误发生与否，我们势必要在传参之前创建<code>NSError</code>对象，这样如果执行过程中没有错误发生，我们创建的<code>NSError</code>对象就没有起到任何作用。</li>
<li>优雅。如果使用一级指针，我们就需要让使用者对我们创建的<code>NSError</code>对象的属性进行修改来写入错误信息。我们在检验错误是否发生的时候也就不能简单的通过判空来实现。</li>
</ol>
<h2 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h2><p>看了上面的一堆东西可能你已经头晕目眩了，也可能你正高兴终于搞懂了。不管怎么样，接下里的路还的走！</p>
<p>Java中的引用乍一听感觉跟C++中的引用比较像，其实它们只是名字像而已，真正跟它比较像的是指针。某种意义上来说Java中的引用其实就是C++中的指针，都是某种结构的变量，变量中保存了所指向的对象的内存地址，只不过受到了一些限制，不能像C++一样灵活的进行各种指针运算、指向任意的内存。</p>
<p>参考文章：<a href="http://blog.csdn.net/linyt/article/details/1573864" target="_blank" rel="external">Java中的对象类型像引用还是指针，谁是谁非？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个使用Objective-C的iOS开发者，指针对很多人来说却是最熟悉的陌生人–虽然每天都在用，但是却对它了解的不是很多。那么指针到底是什么呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;指针即指针变量，是一个存储变量内存地址的变量。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS Development" scheme="http://maxsmak.com/tags/iOS-Development/"/>
    
  </entry>
  
</feed>
