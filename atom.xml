<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MaxMak&#39;s House</title>
  <subtitle>iOS Developer|LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maxsmak.com/"/>
  <updated>2017-04-12T15:51:33.000Z</updated>
  <id>http://maxsmak.com/</id>
  
  <author>
    <name>Max Mak</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MaxMak-Resume</title>
    <link href="http://maxsmak.com/2016/12/30/Resume/"/>
    <id>http://maxsmak.com/2016/12/30/Resume/</id>
    <published>2016-12-30T15:08:42.000Z</published>
    <updated>2017-04-12T15:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><ul>
<li>姓名:<code>麦锡林</code></li>
<li>毕业学院:<code>顺德职业技术学院／计算机网络／2014年毕业</code></li>
<li>工作年限:<code>3年</code></li>
<li>期望职位:<code>iOS开发工程师</code></li>
<li>个人博客:<a href="http://maxsmak.com"><code>http://maxsmak.com</code></a></li>
<li>Github:<a href="http://github.com/MaxsLin" target="_blank" rel="external"><code>http://github.com/MaxsLin</code></a></li>
</ul>
<h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="高卡士智能科技有限公司"><a href="#高卡士智能科技有限公司" class="headerlink" title="高卡士智能科技有限公司"></a><em>高卡士智能科技有限公司</em></h3><h3 id="自动构建平台-开发中"><a href="#自动构建平台-开发中" class="headerlink" title="自动构建平台(开发中)"></a>自动构建平台(开发中)</h3><ul>
<li>项目描述：创建移动项目模版，通过母包打包成子包，修改部分需求资源</li>
<li>责任描述：负责整个项目</li>
<li>技术要点：<ul>
<li>通过Perfect建立初型后台</li>
<li>通过Pathkit处理部分构建前资源</li>
<li>安卓构建Gradle</li>
<li>开发中…</li>
</ul>
</li>
</ul>
<h3 id="名表汇"><a href="#名表汇" class="headerlink" title="名表汇"></a>名表汇</h3><ul>
<li>项目描述：以销售名表为主的电商平台</li>
<li>责任描述：负责整个项目的部分开发工作。</li>
</ul>
<h3 id="小器点"><a href="#小器点" class="headerlink" title="小器点"></a>小器点</h3><ul>
<li>项目描述：通过蓝牙技术集成的防掉软件，主要用于物品防盗，防掉，寻找</li>
<li>责任描述：负责整个项目的需求分析以及开发工作。</li>
<li>技术要点：<ol>
<li>蓝牙框架<code>XQDBluetooth</code>,基于原生<code>CoreBluetooth</code>框架封装的轻量级框架，作为Project中Server端，使用链式方法体封装，对于Bluetooth Module的支持发现、连接、验证,Characteristic 支持WriteRead和Notifiy</li>
<li>数据库框架<code>MaxFMDB</code>,基于开源框架<code>FMDB</code>二次封装,简化了操作数据库，使用链式方法体封装，通过runtime遍历Model Class中的属性创建数据库表，Model中遵循Opintal协议作为主键，通过Model调用Extension Method 实现对于Database的增删减更等操作</li>
<li>定位框架<code>XQDLocaltion</code>,基于原生<code>CoreLocation</code>框架封装,记录每次设备报警位置，通过异步线程上传到服务器</li>
<li>使用BDD的<code>Quick</code>框架作为测试框架</li>
<li>利用RSSI转换距离</li>
<li>OTA升级  </li>
</ol>
</li>
</ul>
<h3 id="风行（iOS）"><a href="#风行（iOS）" class="headerlink" title="风行（iOS）"></a>风行（iOS）</h3><ul>
<li>项目描述：是一款具有社交功能的服务于智能硬件的移动端App。</li>
<li>责任描述：负责整个项目的需求分析以及开发工作。</li>
<li>技术要点：<ol>
<li>使用自定义数据格式通过蓝牙4.0或Wifi来实现App端与智能硬件之间的数据打包、传输、解包以及完整性校验。</li>
<li>封装AFNetworking以实现App端与服务端数据请求权限的统一验证。</li>
<li>自定义实现类似微博timeline的复杂度较高的列表并优化TableView滚动的流畅性。</li>
<li>通过对视频和图片的合理压缩来优化文件上传的速度和体验。</li>
<li>通过使用Autolayout和固定布局相结合的方式来适配iPhone和iPad的各种屏幕大小。</li>
<li>通过使用Mapkit以及CoreLoaction框架实现用户轨迹的录制、保存、纠偏、加偏以及展示。</li>
<li>通过结合APNS、HTTP、Socket以及数据缓存来实现类似微信的即时通讯功能。</li>
<li>通过集成微信、微博、支付宝等第三方SDK来实现应用内购买商品以及分享功能。</li>
<li>通过集成JSPatch以及对称加密来实现安全的热修复功能。</li>
<li>通过对录音的压缩以及传输来实现智能硬件的自定义提示语音的功能。</li>
<li>使用CoreMotion框架来实现通过手机的重力感应对智能硬件前进方向进行远程遥控的功能。</li>
<li>自定义实现列表数据的下拉刷新、上拉加载功能。</li>
<li>通过通知中心扩展的方式对智能硬件进行状态获取、遥控等操作。</li>
</ol>
</li>
<li>技术难点：<ol>
<li>蓝牙数据传输。由于客户端所需要通讯的智能硬件设备中的CPU以及内存等资源没有手机终端这么丰富，再加上BLE传输速度也比较慢，所以通讯时使用应用层比较常见的json和xml格式显然不太现实。因此我们使用自定义的二进制协议进行数据的传输。协议中规定了包头、包尾、功能字、数据字段、控制字符以及扩展格式等内容。根据协议的内容并结合CoreBluetooth框架封装出了一个用于蓝牙连接以及数据打包、传输、解包以及完整性校验的库。如此就可以像发送http请求一样简单地发送命令到智能硬件了。</li>
<li>优化TableView滚动性能。对于复杂度较高的TableView如果不做任何优化，滚动起来就很容易发生卡顿、掉帧现象。开发过程中我通过图片数据后台解码、避免触发离屏渲染、缓存cell的frame和高度、缓存文本排版、异步绘制等方法来对精选和聊天等页面进行优化，使得卡顿、掉帧的频率降低到大多数人可接受的范围内。</li>
</ol>
</li>
</ul>
<h3 id="21Text"><a href="#21Text" class="headerlink" title="21Text"></a>21Text</h3><ul>
<li>项目描述：企业项目</li>
</ul>
<h3 id="北京长地万方科技有限公司"><a href="#北京长地万方科技有限公司" class="headerlink" title="北京长地万方科技有限公司"></a><em>北京长地万方科技有限公司</em></h3><h3 id="室内点云SDK-iOS项目"><a href="#室内点云SDK-iOS项目" class="headerlink" title="室内点云SDK iOS项目"></a>室内点云SDK iOS项目</h3><h3 id="POI采集SDK-iOS项目"><a href="#POI采集SDK-iOS项目" class="headerlink" title="POI采集SDK iOS项目"></a>POI采集SDK iOS项目</h3><h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><ol>
<li>熟悉Objective-c,swift 语言</li>
<li>熟悉自动化集成，Jenkins，travis-ci等</li>
<li>熟悉单元测试，BDD，TDD等</li>
<li>熟悉SVN，Git</li>
<li>设计模式</li>
<li>蓝牙开发/即时通讯/移动支付/LBS/App上架发布</li>
</ol>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul>
<li><strong>Tel</strong>:<code>13929115287</code></li>
<li><strong>Email</strong>:<a href="mailto:maxmak@maxsmak.com"><code>maxmak@maxsmak.com</code></a> </li>
<li><strong>QQ/WeChat</strong>:<code>116355113</code></li>
</ul>
<h2 id="致谢-1"><a href="#致谢-1" class="headerlink" title="致谢"></a>致谢</h2><blockquote>
<p>感谢您花时间垂阅我的简历，期待能有机会和您共事！</p>
</blockquote>
<p>Thank!</p>
<p>Max Mak</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简历&quot;&gt;&lt;a href=&quot;#简历&quot; class=&quot;headerlink&quot; title=&quot;简历&quot;&gt;&lt;/a&gt;简历&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;姓名:&lt;code&gt;麦锡林&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;毕业学院:&lt;code&gt;顺德职业技术学院／计算机网络／2014年毕业&lt;/
    
    </summary>
    
    
      <category term="Resume" scheme="http://maxsmak.com/tags/Resume/"/>
    
  </entry>
  
  <entry>
    <title>浅谈字节序和字节对齐</title>
    <link href="http://maxsmak.com/2015/12/15/Discussed/"/>
    <id>http://maxsmak.com/2015/12/15/Discussed/</id>
    <published>2015-12-15T07:30:36.000Z</published>
    <updated>2017-04-12T04:23:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做智能硬件App开发的过程中，手机端和蓝牙模块之间需要进行传输数据。蓝牙4.0低功耗模式数据传输速度很慢，以我们现在使用的蓝牙模块为例，传输速度大概只有大约1K/s，比起网络传输动辄几百K/s甚至上兆的速度真的是相差甚远。所以为了加快数据的传输速度唯一的办法就是减少要传输的数据的大小了。既然要减少数据量，那我们在网络请求中很常用的xml和json格式就不能用了。因为它里面有很多冗余的数据比如“{}[]”这一类的符号、字段的名称啊之类的信息。因此使用结构体作为数据的载体就是比较符合需求的方式了。</p>
<h2 id="结构体和NSData互转"><a href="#结构体和NSData互转" class="headerlink" title="结构体和NSData互转"></a>结构体和NSData互转</h2><p>iOS的CoreBluetooth框架发送和接收数据都需要使用NSData对象，其实NSData对象和结构体之间很容易进行转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 结构体 -&gt; NSData</div><div class="line">TestStruct test = &#123;1, 2, 3, 4, 5&#125;;</div><div class="line">NSData *data = [NSData dataWithBytes:&amp;test length:sizeof(TestStruct)];</div><div class="line">// NSDta -&gt; 结构体</div><div class="line">TestStruct test;</div><div class="line">[data getBytes:&amp;test length:sizeof(TestStruct)];</div></pre></td></tr></table></figure>
<p>实际使用的过程中你会发现有时候数据并不对，这就涉及到下面要说的字节序和字节对齐的问题了。如果要保证结构体和NSData的互相转换能够成功，就要确保互相通信的各个平台的字节序和字节对齐方式要统一。</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。</p>
<p>而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序（Little Endian）；反之则称大端序（Big Endian）。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。</p>
<p>例如假设上述变量x类型为int，位于地址0x100处，它的十六进制为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 01, 0x101: 23,..。而小端法将是：0x100: 67, 0x101: 45,..。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint32_t</span> a = <span class="number">0x12345678</span>;</div><div class="line">NSLog(@<span class="string">"%@"</span>, [NSData dataWithBytes:&amp;a length:<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)]);</div></pre></td></tr></table></figure>
<p>由于Mac和iOS都是采用的小端序，所以下面的代码的输出结果为<code>&lt;78563412&gt;</code></p>
<h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>先来看一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">uint64_t a;</div><div class="line">uint8_t  b;</div><div class="line">uint32_t c;</div><div class="line">uint8_t  d;</div><div class="line">uint16_t e;</div><div class="line">&#125; TestStruct;</div><div class="line">TestStruct test = &#123;1, 2, 3, 4, 5&#125;;</div><div class="line">NSUInteger length = sizeof(TestStruct);</div><div class="line">NSLog(@&quot;%ld %@&quot;, length, [NSData dataWithBytes:&amp;test length:length]);</div></pre></td></tr></table></figure>
<p>乍一看length不应该是8+1+4+1+2=16个字节吗？但是实际的输出的结果是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">24 &lt;01000000 00000000 02000000 03000000 04000500 00000000&gt;</div></pre></td></tr></table></figure>
<p>这是为什么呢？这就不得不说一说字节对齐了。</p>
<p><strong>为什么要进行字节对齐</strong></p>
<p>在计算机中数据存储和传输以位(bit)为单位，每8个位bit组成1个字节(Byte)。32位计算机的字长为32位，即4个字节；对应的，64位计算机的字长为64位，即8个字节。计算机系统对基本类型数据在内存中存放的位置有限制，要求这些数据的起始地址的值是某个数k的倍数，这就是所谓的内存对齐，而这个k则被称为该数据类型的对齐模数(alignment modulus)。</p>
<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数 据。显然在读取效率上下降很多。</p>
<p><strong>如何对齐</strong></p>
<ol>
<li>结构体的起始位置的偏移量必须是能够被该结构体中最大的数据类型所整除。</li>
<li>每个数据成员存储的起始位置的偏移量是自身大小的整数倍(比如int在32位机为4字节，则int型成员要从4的整数倍地址开始存储)。</li>
<li>结构体总大小（也就是sizeof的结果），必须是该结构体成员中最大的对齐模数的整数倍。若不满足，会根据需要自动填充空缺的字节。</li>
<li>结构体包含另一个结构体成员，则被包含的结构体成员要从其原始结构体内部最大对齐模数的整数倍地址开始存储。(比如struct a里存有struct b，b里有char,int,double等元素,那b应该从8的整数倍开始存储。)</li>
<li>结构体包含数组成员，比如char a[3],它的对齐方式和分别写3个char是一样的，也就是说它还是按一个字节对齐。如果写：typedef char Array[3],Array这种类型的对齐方式还是按一个字节对齐，而不是按它的长度3对齐。</li>
<li>结构体包含共用体成员，则该共用体成员要从其原始共用体内部最大对齐模数的整数倍地址开始存储。</li>
</ol>
<p>根据上面的对齐规则，成员a的起始位置偏移量为0，长度为8个字节；成员b的偏移量为8，长度为1个字节；成员c的偏移量为8+1=9，9无法整除成员c的长度4，所以在b和c之间自动填充空间对齐c的偏移量到12；成员d的偏移量为12＋4=16，长度为一个字节；成员e的偏移量为16+1=17，17无法整除e的长度2，自动对齐e的偏移量至18；整个结构体的长度为18+2=20个字节，无法整除结构体中最大的数据类型的长度8，因此自动填充空间至24个字节。</p>
<p>前面说过，字节对齐对CPU读取内存的效率会有很大的提升。但是不同平台，不同的编译器可能会有不同的对齐方式。如果对齐方式不同，我们使用结构体进行数据的传输就会出现问题。统一对齐方式的最简单的方法就是采用1字节对齐。1字节对齐其实就相当于是不进行对齐，这样做就降低了CPU读取内存的效率，不过相对于数据传输的便利，这点损耗无足轻重。那么怎么让编译器不进行对齐操作呢？只需要在结构体声明的时候加一个<br><code>__attribute__((packed))</code> 例如下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">uint64_t a;</div><div class="line">uint8_t  b;</div><div class="line">uint32_t c;</div><div class="line">uint8_t  d;</div><div class="line">uint16_t e;</div><div class="line">&#125; __attribute__((packed)) TestStruct;</div><div class="line">TestStruct test = &#123;1, 2, 3, 4, 5&#125;;</div><div class="line">NSUInteger length = sizeof(TestStruct);</div><div class="line">NSLog(@&quot;%ld %@&quot;, length, [NSData dataWithBytes:&amp;test length:length]);</div></pre></td></tr></table></figure>
<p>加上这个之后输出结果就变成了</p>
<p><code>16 &lt;01000000 00000000 02030000 00040500&gt;</code></p>
<p>这下就跟我们预想的一致了。</p>
<p>参考资料：</p>
<p><a href="https://zh.wikipedia.org/zh/字节序" target="_blank" rel="external">维基百科：字节序</a></p>
<p><a href="http://blog.csdn.net/baidu_31364929/article/details/49383623" target="_blank" rel="external">iOS开发关系结构体分配空间</a></p>
<p><a href="http://skx926.com/2016/07/31/byte-order/" target="_blank" rel="external">C++结构体字节对齐</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做智能硬件App开发的过程中，手机端和蓝牙模块之间需要进行传输数据。蓝牙4.0低功耗模式数据传输速度很慢，以我们现在使用的蓝牙模块为例，传输速度大概只有大约1K/s，比起网络传输动辄几百K/s甚至上兆的速度真的是相差甚远。所以为了加快数据的传输速度唯一的办法就是减少要传输
    
    </summary>
    
    
      <category term="iOS Development" scheme="http://maxsmak.com/tags/iOS-Development/"/>
    
  </entry>
  
  <entry>
    <title>指针</title>
    <link href="http://maxsmak.com/2015/10/02/Pointer/"/>
    <id>http://maxsmak.com/2015/10/02/Pointer/</id>
    <published>2015-10-02T03:09:16.000Z</published>
    <updated>2017-04-12T03:37:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>作为一个使用Objective-C的iOS开发者，指针对很多人来说却是最熟悉的陌生人–虽然每天都在用，但是却对它了解的不是很多。那么指针到底是什么呢？</p>
<blockquote>
<p>指针即指针变量，是一个存储变量内存地址的变量。</p>
</blockquote>
<p>这句话可能有点绕，我们举个例子来说一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;a;</div></pre></td></tr></table></figure>
<p>上面的代码首先声明了一个<code>int</code>类型的变量<code>a</code>，它的值为<code>0</code>。然后又声明了一个指针类型的变量<code>p</code>，<code>p</code>这个变量存储的值就是<code>a</code>变量的内存地址。</p>
<h2 id="C-中的引用"><a href="#C-中的引用" class="headerlink" title="C++中的引用"></a>C++中的引用</h2><blockquote>
<p>引用是变量的别名。</p>
</blockquote>
<p>我们同样举个例子来说一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> &amp;b = a;</div></pre></td></tr></table></figure>
<p>首先声明了一个<code>int</code>类型的变量<code>a</code>，它的值为<code>0</code>，然后又声明了一个<code>a</code>的引用<code>b</code>，<code>b</code>只是<code>a</code>的一个别名而已，并没有占用内存空间。实际上他们是同一个同西，在内存中占用同样的一个存储单元。</p>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>除了在定义上的区别，他们还有很多不同：</p>
<ol>
<li>有<code>const</code>指针，没有<code>const</code>引用。</li>
<li>指针可以有很多级，而引用只有一级（比如<code>int **p</code>是合法的，而<code>int &amp;&amp;b</code>是不合法的）。</li>
<li>指针可以为空，而引用不能为空，定义的时候必须对其进行初始化。</li>
<li>指针的值可以在初始化之后改变，而引用在初始化之后就不能变了。<br><code>sizeof(引用)</code>得到的是引用所表示的变量的大小，而<code>sizeof(指针)</code>得到的是指针本身的大小。</li>
</ol>
<h2 id="令人迷惑的-和-amp"><a href="#令人迷惑的-和-amp" class="headerlink" title="令人迷惑的*和&amp;"></a>令人迷惑的*和&amp;</h2><p><code>*</code>有两种含义，表示乘法和指针。<code>&amp;</code>有点复杂，它既表示位运算的与，又表示取地址，还表示引用，两个<code>&amp;</code>拼在一起<code>&amp;&amp;</code>又表示逻辑运算的且（天哪，为什么它的事情这么多！）。我们来看一段代码压压惊：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;a;</div><div class="line">*p = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> &amp;b = b;</div><div class="line">b = <span class="number">2</span>;</div></pre></td></tr></table></figure>
<p>第一行没啥说的，我们来看第二行：<code>int *p = &amp;a;</code>表示的是声明一个int类型的名叫p的指针变量并把a的地址赋给它，所以这行代码其实应该写成这样<code>int* p = &amp;a</code>。但是为什么我们一般要写成第一种形式呢？其实是为了防止引起歧义。比如<code>int* p, p1;</code>，这里的p1到底是指针类型呢还是int类型？这样写的话很容易让人感觉p1是指针类型的，而实际上它是<code>int</code>类型的。所以为了防止产生歧义，要声明两个指针我们就要写成这样<code>int *p, *p1;</code>。</p>
<p>说的好像很有道理的样子，那么第二行又是什么鬼？<code>*p</code>不是表示指针吗？为什么会给它赋值<code>1</code>？好吧，其实<code>p</code>才是指针，这里的<code>*</code>是解引用的意思，为了不跟上面说的引用产生歧义，你可以把它理解成解指针。所以<code>*p</code>指的是解引用，也就是根据p中所存储的内存地址来拿到p所指向的内存空间然后写入整数<code>1</code>。</p>
<p>所以同样的<code>*</code>号在变量声明的时候其实只是为了告诉编译器你要声明的变量是一个指针类型的变量，仅此而已。而在使用的时候<code>*</code>号表示的是引用的意思。</p>
<p><code>&amp;</code>号在声明的时候也同样只是为了告诉编译器你要创建一个变量的别名，与<code>*</code>号不同的是在使用的时候并不需要解引用之类的操作，直接使用引用名即可（如代码第五行所示）。需要注意的是如果在使用时候在变量名前加上<code>&amp;</code>符号就表示取这个变量的地址（如代码第二行所示）。</p>
<h2 id="值传递、指针传递、引用传递"><a href="#值传递、指针传递、引用传递" class="headerlink" title="值传递、指针传递、引用传递"></a>值传递、指针传递、引用传递</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    a++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase1</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</div><div class="line">    (*p)++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase2</span><span class="params">(<span class="keyword">int</span> &amp;b)</span> </span>&#123;</div><div class="line">    b++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    increase(a);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</div><div class="line">    <span class="keyword">int</span> *p = &amp;a;</div><div class="line">    increase1(p);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</div><div class="line">    <span class="keyword">int</span> &amp;b = a;</div><div class="line">    increase2(b);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码中的三个函数分别对应<code>值传递</code>、<code>指针传递</code>和<code>引用传递</code>，输出结果为<code>0 1 2</code>。说明第一个函数并没有改变<code>a</code>的值，是因为在<code>值传递的过程中会对传递的变量进行一次拷贝</code>，<code>increase</code>函数改变的不是<code>a</code>而是<code>a</code>的拷贝，并不会对<code>a</code>造成影响。既然值传递会进行拷贝，那么指针也是一个变量，指针传递的过程中应该也会对指针进行拷贝。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase1</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, p);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, &amp;p);</div><div class="line">    (*p)++;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> *p = &amp;a;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, p);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, &amp;p);</div><div class="line">    increase1(p);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码输出结果为<code>5FBFF74C 5FBFF740 5FBFF74C 5FBFF718</code>，我们发现传递前和传递后指针<code>p</code>的值没有发生变化，但是<code>p</code>的地址却发生了变化。这说明指针传递的过程中也会发生拷贝，不过拷贝的是指针，而指针所指向的内存地址不会发生改变，这也是变量<code>a</code>的值能够被修改的原因。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase2</span><span class="params">(<span class="keyword">int</span> &amp;b)</span> </span>&#123;</div><div class="line">    b++;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, &amp;b);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%X\n"</span>, &amp;a);</div><div class="line">    increase2(a);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码的输出结果为<code>0 5FBFF74C 1 5FBFF74C</code>，这说明引用传递的过程中并没有发生值拷贝，传过去的引用和原来的变量是同一个东西，所以对它的修改就是对<code>a</code>的修改。</p>
<h2 id="关于NSError"><a href="#关于NSError" class="headerlink" title="关于NSError"></a>关于NSError</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSError *error;</div><div class="line">[[NSFileManager defaultManager] moveItemAtPath:srcPath toPath:dstPath error:&amp;error];</div><div class="line">if (error) &#123;</div><div class="line">    // handle error.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开发过程中经常会用到类似上面的代码，大家都知道NSError是这么用的，但是很多初学者对于为什么这样写却说不出个所以然。我们首先来看一下这个方法的声明<code>- (BOOL)moveItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error;</code>，通过这个方法的声明我们可以知道这里其实需要的是一个<code>NSError**</code>类型的参数。所以这段代码的意思是先创建一个<code>NSError</code>类型的指针变量<code>error</code>（并没有创建<code>NSError</code>对象），然后把它的地址传递过去，当<code>NSFileManager</code>对象在执行的过程中发生了错误就会创建一个<code>NSError</code>对象并把它的地址写入我们之前创建的<code>error</code>指针的内存空间，也就是让<code>error</code>指针指向新创建的<code>NSError</code>对象。</p>
<p>有人可能会问这里为什么要用二级指针<code>NSError**</code>，而不是用用一级指针<code>NSError*</code>？我觉得有以下两点原因：</p>
<ol>
<li>节省内存。如果使用一级指针，无论错误发生与否，我们势必要在传参之前创建<code>NSError</code>对象，这样如果执行过程中没有错误发生，我们创建的<code>NSError</code>对象就没有起到任何作用。</li>
<li>优雅。如果使用一级指针，我们就需要让使用者对我们创建的<code>NSError</code>对象的属性进行修改来写入错误信息。我们在检验错误是否发生的时候也就不能简单的通过判空来实现。</li>
</ol>
<h2 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h2><p>看了上面的一堆东西可能你已经头晕目眩了，也可能你正高兴终于搞懂了。不管怎么样，接下里的路还的走！</p>
<p>Java中的引用乍一听感觉跟C++中的引用比较像，其实它们只是名字像而已，真正跟它比较像的是指针。某种意义上来说Java中的引用其实就是C++中的指针，都是某种结构的变量，变量中保存了所指向的对象的内存地址，只不过受到了一些限制，不能像C++一样灵活的进行各种指针运算、指向任意的内存。</p>
<p>参考文章：<a href="http://blog.csdn.net/linyt/article/details/1573864" target="_blank" rel="external">Java中的对象类型像引用还是指针，谁是谁非？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;/h2&gt;&lt;p&gt;作为一个使用Objective-C的iOS开发者，指针对很多人来说却是最熟悉的陌生人–虽然每天都在用，但是却对它了解的不是很多。那么指针到底
    
    </summary>
    
    
      <category term="iOS Development" scheme="http://maxsmak.com/tags/iOS-Development/"/>
    
  </entry>
  
</feed>
